<sdp_diaglet platform="aix" product="IM1014" set="A360IM1014_aix" title="Oracle Identity Management 10g (10.1.4) Preinstall (AIX)" type="A">
<sdp_meta type="version" id="$Id: A360IM1014_aix.xml,v 1.8 2012/04/18 16:34:59 mschenke Exp $" header="$Header: /home/cvs/cvs/RDA_4/src/scripting/lib/hcve/A360IM1014_aix.xml,v 1.8 2012/04/18 16:34:59 mschenke Exp $" version="1.0"/>
<sdp_meta author="JCR" change="Improve Temp Space check" date="20120406" type="history"/>
<sdp_content set="A360IM1014_aix" title="Oracle Identity Management 10g (10.1.4) Preinstall (AIX)" type="check">
<sdp_group>

<sdp_rule id="A00010" mode="RECORD" name="OS">
<sdp_command type="RDA"><![CDATA[import $OS_PLT,$OS_NAM,$OS_VER,$OS_LVL,$OS_BIT
var $BOOK = undef
call setHcveVariable('$BOOK')
var $BOOK = 'Oracle Application Server Installation Guide 10g (10.1.4.0.1) \
             for AIX 5L Based Systems'
call setHcveResult(concat($OS_PLT,' ',$OS_VER,' ',$OS_LVL,' ',$OS_BIT,'-bit'))
]]>
</sdp_command>
<sdp_description><![CDATA[This rule retrieves the operating system (OS) description.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A00020" mode="VERIFY" name="Processor 64-bit?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','/usr/bin/getconf')
 return setHcveResult('Cannot access /usr/bin/getconf')
if grepCommand('/usr/bin/getconf HARDWARE_BITMODE','64','f')
 return setHcveResult('Acceptable')
else
 return setHcveResult('Not 64-bit')]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the processor is 64-bit]]></sdp_description>
<sdp_actions>
<sdp_action condition='==' minimum="Acceptable" result="PASSED"><![CDATA[The processor is acceptable]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Cannot access /usr/bin/getconf|Make sure the user has access to ``/usr/bin/getconf``.|
|Not 64-bit|You must use a 64-bit processor.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00025" mode="VERIFY" name="Processor CHRP?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','bootinfo')
 return setHcveResult('Cannot execute bootinfo')
if grepCommand('bootinfo','chrp','if')
 return setHcveResult('Acceptable')
else
 return setHcveResult('NotCHRP')]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the processor is Common Hardware Reference Platform (CHRP).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Acceptable" result="PASSED"><![CDATA[The processor is Common Hardware Reference Platform]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Cannot execute bootinfo|Make sure the user has appropriate privileges.|
|NotCHRP|The processor must be Common Hardware Reference Platform.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00030" mode="VERIFY" name="Processor Speed OK?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','/usr/sbin/prtconf')
 return setHcveResult('Cannot access /usr/sbin/prtconf')
var ($lin) = grepCommand('/usr/sbin/prtconf','Clock\s+Speed','if')
var $mhz = field('\s+',3,$lin)
call setHcveResult(cond(\
 expr('>=',$mhz,450),\
  'The minimum requirement for the processor speed has been met.',\
   concat('Processor speed [',$mhz,'MHZ] does not meet minimum requirement')))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks for the processor speed. The minimum requirement is 450 MHz or faster.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="The minimum requirement for the processor speed has been met." result="PASSED"><![CDATA[The minimum requirement for the processor speed is met.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Processor speed ... does not meet minimum requirement|Use a processor with a speed of 450 MHz or faster.|
|Cannot access /usr/sbin/prtconf|Grant execute permissions on ``/usr/sbin/prtconf`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00110" mode="VERIFY" name="OS OIMgr Certified?">
<sdp_dependencies>
<sdp_dependency id="A00020" condition="IS" minimum="PASSED" result="SKIPPED" value="Processor must be 64-bit">
<![CDATA[RequireS processor to be 64-bit]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_VER
call setHcveResult(cond(\
  match($OS_VER,'^5\.3'),'Certified','Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Identity Manager (OIMgr).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Identity Manager.]]></sdp_action>
<sdp_action condition="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Identity Manager. The certified AIX operating systems are: AIX 5.3 32-bit or 64-bit]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00120" mode="VERIFY" name="OS OIF Certified?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A00020" minimum="PASSED" result="SKIPPED" value="Processor must be 64-bit">
<![CDATA[Requires processor to be 64-bit.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_LVL
var $lvl = substr($OS_LVL,5,2)
call setHcveResult(cond(\
  and(match($OS_VER,'^5\.2'),expr('>=',$lvl,'04')),'Certified',\
  and(match($OS_VER,'^5\.3'),expr('>=',$lvl,'02')),'Certified',\
  match($OS_VER,'^6\.1'),                          'Certified',\
  'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Identity Federation (OIF).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Identity Federation.]]></sdp_action>
<sdp_action condtiion="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Identity Federation. The certified AIX operating systems are: AIX 5.2 ML04, AIX 5.3 ML02, AIX 6.1]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00140" mode="VERIFY" name="OS OVD Certified?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A00020" minimum="PASSED" result="SKIPPED" value="Processor must be 64-bit">
<![CDATA[Requires processor to be 64-bit.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_BIT
call setHcveResult(cond(\
  and(match($OS_VER,'^5\.3'),match($OS_BIT,'64')),'Certified','Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Virtual Directory (OVD).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Virtual Directory.]]></sdp_action>
<sdp_action condition="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Virtual Directory. The certified AIX operating system is: AIX 5.3 64-bit]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00150" mode="VERIFY" name="OS ORM Certified?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A00020" minimum="PASSED" result="SKIPPED" value="Processor must be 64-bit">
<![CDATA[Requires processor to be 64-bit.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_VER
call setHcveResult(cond(\
  match($OS_VER,'^5\.3'),'Certified','Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Role Manager (ORM).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Role Manager.]]></sdp_action>
<sdp_action condition="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Role Manager. The certified AIX operating systems are: AIX 5.3 32-bit or 64-bit]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00160" mode="VERIFY" name="OS OAAM Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_VER
call setHcveResult(cond(\
  match($OS_VER,'^5\.3'),'Certified','Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Adaptive Access Manager.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Adaptive Access Manager.]]></sdp_action>
<sdp_action condition="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Adaptive Access Manager. The certified AIX operating sytems are: AIX 5.3 32-bit or 64-bit]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00170" mode="VERIFY" name="OS OID and SSO Certified?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A00020" minimum="PASSED" result="SKIPPED" value="Processor must be 64-bit">
<![CDATA[Requires processor to be 64-bit.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_LVL
var $lvl = substr($OS_LVL,5,2)
call setHcveResult(cond(\
  and(match($OS_VER,'^5\.2'),expr('>=',$lvl,'04')),'Certified',\
  and(match($OS_VER,'^5\.3'),expr('>=',$lvl,'02')),'Certified',\
  match($OS_VER,'^6\.1'),                          'Certified',\
                                                   'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Internet Directory (OID) and Oracle Application Server Single Sign-On (SSO).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED"><![CDATA[The operating system is certified for Oracle Internet Directory and Oracle Application Server Single Sign-On.]]></sdp_action>
<sdp_action condition="==" minimum="Not Certified" result="FAILED"><![CDATA[The operating system is not certified for Oracle Internet Directory and Oracle Applicatin Server Single Sign-On. The certified AIX operating systems are: AIX 5.2 ML04 32-bit and 64-bit, AIX 5.3 ML02 32-bit and 64-bit, AIX 6.1 32-bit and 64-bit]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00200" mode="RECORD" name="Physical Memory">
<sdp_command type="RDA"><![CDATA[var $MEM = undef
call setHcveVariable('$MEM')
if !testFile('x','/usr/sbin/prtconf')
 return setHcveResult('Cannot access /usr/sbin/prtconf')
var $MEM = field('\s+',2,grepCommand('/usr/sbin/prtconf','Memory','f'))
if expr('>',$MEM,0)
 call setHcveResult(concat($MEM,' MB'))
else
 call setHcveResult('No access to /usr/sbin/prtconf')]]>
</sdp_command>
<sdp_description><![CDATA[This rule retrieves the available physical memory in MB.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A00300" mode="Verify" name="Memory MDR and OIM OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required">
<![CDATA[This rule needs amount of physical memory.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,1024),'Available',\
                       'Need at least 1 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Metadata Repository (MDR) and Oracle Identity Management (OIM) installation type. The minimum requirement is 1GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Metadata Repository and Oracle Identity Management installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1 GB|Increase the memory to 1 GB or more to install the Metadata Repository and Oracle Identity Management installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00310" mode="VERIFY" name="Memory OIM OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required">
<![CDATA[This rule needs amount of physical memory.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,512),'Available',\
                      'Need at least 512 MB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Identity Management only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Identity Management only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 512 MB|Increase the memory to 512 MB or more to install the Oracle Identity Management only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00320" mode="VERIFY" name="Memory MDR OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required">
<![CDATA[This rule needs amount of physical memory.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,750),'Available',\
                      'Need at least 750 MB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Metadata Repository (MDR) only installation type. The minimum requirement is 750 MB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Metadata Repository only installation type.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 750 MB|Increase the memory to 750 MB or more to install the Metadata Repository only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00330" mode="VERIFY" name="Memory OIF OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required"><![CDATA[This rule needs amount of physical memory.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,512),'Available',\
                      'Need at least 512 MB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Identity Federation (OIF) only installation type. The minimum requirement is 512 MB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Identity Federation only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 512 MB|Increase the memory to 512 MB or more to install the Oracle Identity Federation only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00400" mode="VERIFY" name="Temp Space OK?">
<sdp_command type="RDA"><![CDATA[
var ($flg,$tmp,@tbl) = (true,{'/tmp','/tmp'})
loop $key ('TMP','TMPDIR')
{if getEnv($key)
  var $tmp->{$key} = last
}
loop $key (keys(%tmp))
{if !testDir('d',$tmp->{$key})
  call push(@tbl,concat($key,' invalidDir'))
 else
 {if !testDir('w',$tmp->{$key})
   call push(@tbl,concat($key,' NoWrite'))
  if and($flg,expr('>=',get_df($tmp->{$key}),409600))
   var $flg = false
 }
}
if $flg
{loop $key (keys(%tmp))
  call push(@tbl,concat($key,' tooSmall'))
}
call setHcveParameter('RULE.A00400',$tmp)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'TempSpaceOK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough temporary space. Initially Oracle Universal Installer (OUI) checks the ``TMP`` and ``TMPDIR`` environment variables to locate the temporary directory. If these environment variables do not exist, then OUI uses ``/tmp``. The minimum requirement is 400 MB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="TempSpaceOK" result="PASSED"><![CDATA[There is adequate space in your temporary space directory.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The temporary space is not configured correctly.
|*Return Value*|*Action*|
|/tmp invalidDir|ALERT - ``/tmp`` is not a valid directory. ``/tmp`` needs to be a directory.|
|/tmp NoWrite|ALERT - The user does not have write permissions to the ``/tmp`` directory.|
|/tmp tooSmall|ALERT - There is less than the needed 400 MB of free space in the ``/tmp`` directory.|
|TMP invalidDir|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, ${`RULE.A00400.TMP} is an invalid directory. Take appropriate action.|
|TMP NoWrite|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, the user does not have write permissions to ${`RULE.A00400.TMP}.|
|TMP tooSmall|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, ${`RULE.A00400.TMP} has less than the required 400 MB of free space. Make sure your temporary space has at least 400 MB of free space.|
|TMPDIR invalidDir|ALERT - ``TMPDIR`` is set to ${`RULE.A00400.TMPDIR} in the environment; however, ${`RULE.A00400.TMPDIR} is an invalid directory. Take appropriate action.|
|TMPDIR NoWrite|ALERT - ``TMPDIR`` is set to ${`RULE.A00400.TMPDIR} in the environment; however, the user does not have write permissions to ${`RULE.A00400.TMPDIR}.|
|TMPDIR tooSmall|ALERT - ``TMPDIR`` is set to ${`RULE.A00400.TMPDIR} in the environment; however, ${`RULE.A00400.TMPDIR} has less than the required 400 MB of free space. Make sure your temporary space has at least 400 MB of free space.|
]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00410" mode="VERIFY" name="Swap space OK?">
<sdp_command type="RDA"><![CDATA[call setHcveResult(cond(\
  not(testFile('x','/usr/sbin/lsps')),\
    'Cannot access /usr/sbin/lsps',\
  expr('>=',replace(field('\s+',0,\
    grepCommand('/usr/sbin/lsps -s','\d+','f')),'MB'),1536),\
    'Available',\
    'Need at least 1.5 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough swap space. The minimum requirement is 1.5 GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED"><![CDATA[The system has enough swap space.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1.5 GB|Increase the swap space to 1.5 GB or more.|
|Cannot access /usr/sbin/lsps|Grant execute permissions on ``/usr/sbin/lsps`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00420" mode="RECORD" name="Disk Space">
<sdp_command type="RDA"><![CDATA[var $ORACLE_HOME = getEnv('ORACLE_HOME')
var $DU = cond(\
  not($ORACLE_HOME),             'ORACLE_HOME is not set',\
  not(testDir('d',$ORACLE_HOME)),'Cannot access ORACLE_HOME',\
                                 get_df($ORACLE_HOME))
call setHcveVariable('$DU')
call setHcveResult(cond(isNumber($DU),concat($DU,' KB'),$DU))]]>
</sdp_command>
<sdp_description><![CDATA[This rule retrieves the available disk space.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum=" KB$" result="PASSED"><![CDATA[No action is required.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|ORACLE_HOME is not set|Set the ORACLE_HOME environment variable.|
|Cannot access ORACLE_HOME|Set ORACLE_HOME to a valid directory.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00500" mode="VERIFY" name="Disk space Infra OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required">
<![CDATA[This rule needs available disk space.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  expr('>=',$dsk,6.2),'Available','Need 6.2 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Infrastructure installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Infrastructure installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 6.2 GB|Increase the available space to 6.2 GB or more to install the Infrastructure installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00510" mode="VERIFY" name="Disk space OIM OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required">
<![CDATA[This rule needs available disk space.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  expr('>=',$dsk,1.7),'Available','Need 1.7 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Identity Manager (OIM) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Identity Manager only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 1.7 GB|Increase the available space to 1.7 GB or more to install the Oracle Identity Manager only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00520" mode="VERIFY" name="Disk space MDR OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required">
<![CDATA[This rule needs available disk space.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  expr('>=',$dsk,4.5),'Available','Need 4.5 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Application Server Metadata Repository (MDR) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Application Server Metadata Repository only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 4.5 GB|Increase the available space to 4.5 GB or more to install the Oracle Application Server type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00530" mode="VERIFY" name="Disk space OIF OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required">
<![CDATA[This rule needs available disk space.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  expr('>=',$dsk,1.8),'Available','Need 1.8 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Identity Federation (OIF) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Identity Federation installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 1.8 GB|Increase the available space to 1.8 GB or more to install the Oracle Identity Federation installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00600" mode="VERIFY" name="AIX 5.2 ML OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.2" result="SKIPPED" value="Not on AIX 5.2">
<![CDATA[This rule is for AIX 5.2.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_LVL
var $lvl = substr($OS_LVL,5,2)
call setHcveResult(cond(\
  expr('>=',$lvl,'04'),'Satisfactory','Insufficient'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if AIX 5.2 is at maintenance level (ML) 4 or above]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Satisfactory" result="PASSED"><![CDATA[AIX 5.2 is at a satisfactory maintenance level.]]></sdp_action>
<sdp_action condition="==" minimum="Insufficient" result="FAILED"><![CDATA[AIX 5.2 must be brought up to maintenance level 4 or above.]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00610" mode="VERIFY" name="AIX 5.2 Filesets OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.2" result="SKIPPED" value="Not on AIX 5.2">
<![CDATA[This rule only applies to AIX 5.2.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[if !testFile('ex','/usr/bin/lslpp')
 return setHcveResult('Cannot access /usr/bin/lslpp')
loop $set ('bos.adt.base',\
           'bos.adt.lib',\
           'bos.adt.libm',\
           'bos.perf.perfstat',\
           'bos.perf.libperfstat',\
           'bos.perf.proctools',\
           'X11.motif.lib')
{var ($res) = grepCommand(concat('lslpp -l ',$set),quote($set),'f')
 if !length($res)
  call push(@tbl,$set)
 elsif !compare('eq',field('\s+',2,$res),'COMMITTED')
  call push(@tbl,$set)
}
call setHcveResult(cond(\
  scalar(@tbl),concat('Missing [',join(' ',@tbl),']'),'All required filesets installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the following filesets are installed and committed: ``bos.adt.base`` ``bos.adt.lib`` ``bos.adt.libm`` ``bos.perf.perfstat`` ``bos.perf.libperfstat`` ``bos.perf.proctools`` ``X11.motif.lib``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required filesets installed" result="PASSED"><![CDATA[All required filesets are installed.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Missing ...|Install the listed missing filesets.|
|Cannot access /usr/bin/lslpp|Grant execute permissions on ``/usr/bin/lslpp`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00620" mode="VERIFY" name="AIX 5.2 Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.2" result="SKIPPED" value="Not on AIX 5.2">
<![CDATA[This rule only applies to AIX 5.2.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !testFile('ex','/usr/sbin/instfix')
 return setHcveResult('Cannot access /usr/sbin/instfix')
macro chk_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {if !grepCommand(concat('/usr/sbin/instfix -ia -ivk ',$pch),$pch,'f')
   call push(@tbl,$pch)
 }
}
call chk_patch(\@tbl,'IY65001','IY64978','IY64737','IY64691','IY63366',\
                     'IY63133','IY69518','IY75901','IY59082')
call setHcveResult(cond(\
  scalar(@tbl),concat('Missing [',join(' ',@tbl),']'),'All required patches \
                                                      installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches are installed.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED"><![CDATA[All required operating system patches are installed.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Missing ...|Install the missing patches.|
|Cannot access /usr/sbin/instfix|Grant execute permissions on ``/usr/sbin/instfix`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00630" mode="VERIFY" name="AIX 5.3 ML OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.3" result="SKIPPED" value="Not on AIX 5.3">
<![CDATA[This rule is for AIX 5.3.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_LVL
var $lvl = substr($OS_LVL,5,2)
call setHcveResult(cond(\
  expr('>=',$lvl,'02'),'Satisfactory','Insufficient'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if AIX 5.3 is at maintenance level (ML) 2 or above]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Satisfactory" result="PASSED"><![CDATA[AIX 5.3 is at a satisfactory maintenance level.]]></sdp_action>
<sdp_action condition="==" minimum="Insufficient" result="FAILED"><![CDATA[AIX 5.3 must be brought up to maintenance level 2 or above.]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00640" mode="VERIFY" name="AIX 5.3 Filesets OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.3" result="SKIPPED" value="Not on AIX 5.3">
<![CDATA[This rule only applies to AIX 5.3.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[if !testFile('ex','/usr/bin/lslpp')
 return setHcveResult('Cannot access /usr/bin/lslpp')
loop $set ('bos.adt.base',\
           'bos.adt.lib',\
           'bos.adt.libm',\
           'bos.perf.perfstat',\
           'bos.perf.libperfstat',\
           'bos.perf.proctools',\
           'X11.motif.lib')
{var ($res) = grepCommand(concat('lslpp -l ',$set),quote($set),'f')
 if !length($res)
  call push(@tbl,$set)
 elsif !compare('eq',field('\s+',2,$res),'COMMITTED')
  call push(@tbl,$set)
}
call setHcveResult(cond(\
  scalar(@tbl),concat('Missing [',join(' ',@tbl),']'),'All required filesets installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the following filesets are installed and committed: ``bos.adt.base`` ``bos.adt.lib`` ``bos.adt.libm`` ``bos.perf.perfstat`` ``bos.perf.libperfstat`` ``bos.perf.proctools`` ``X11.motif.lib``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required filesets installed" result="PASSED"><![CDATA[All required filesets are installed.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Missing ...|Install the listed missing filesets.|
|Cannot access /usr/bin/lslpp|Grant execute permissions on ``/usr/bin/lslpp`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00650" mode="VERIFY" name="AIX 5.3 Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^AIX 5.3" result="SKIPPED" value="Not on AIX 5.3">
<![CDATA[This rule only applies to AIX 5.3.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !testFile('x','/usr/sbin/instfix')
 return setHcveResult('Cannot access /usr/sbin/instfix')
macro chk_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {if !grepCommand(concat('/usr/sbin/instfix -ia -ivk ',$pch),$pch,'f')
   call push(@tbl,$pch)
 }
}
call chk_patch(\@tbl,'IY70159','IY66513','IY68989')
call setHcveResult(cond(scalar(@tbl),concat('Missing [',join(' ',@tbl),']'),\
                                     'All required patches installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches are installed.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED"><![CDATA[All required operating system patches are installed.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Missing ...|Install the missing patches.|
|Cannot access /usr/sbin/instfix|Grant execute permissions on ``/usr/sbin/instfix`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01000" mode="VERIFY" name="AIX Params OK?">
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if loadCommand('/usr/sbin/lsattr -El sys0 -a maxuproc')
{var $prc = field('\s+',1,grepLastFile('^maxuproc'))
 if !$prc
  push(@tbl,'MaxuprocNotDefined')
 elsif expr('<',$prc,2048)
  push(@tbl,'MaxuprocTooSmall')
} 
else
 push(@tbl,'NoLsattrAccess')
if loadCommand('/usr/bin/getconf ARG_MAX')
{if expr('<',grepLastFile('\d+'),524288)
  push(@tbl,'ArgMaxTooSmall')
} 
else
 push(@tbl,'NoGetconfAccess')
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel settings are set appropriately.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK" result="PASSED" syntax="wiki"><![CDATA[The kernel parameters are set according to the ${'BOOK}. No action required.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. 
|*Return Value*|*Action*|
|MaxuprocTooSmall|Increase the kernel setting ``maxuproc`` to 2048.|
|MaxuprocNotDefined|Set the kernel setting ``maxuproc`` to 2048.|
|ArgMaxTooSmall|Increase the kernel setting ``ARG_MAX`` to 524288.|
|NoGetcongAccess|You do not have access to the ``/usr/bin/getconf`` command.|
|NoLsattrAccess|You do not have access to the ``/usr/biin/lsattr`` command.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01100" mode="RECORD" name="Domain Name">
<sdp_command type="RDA"><![CDATA[var ($hst) = command('hostname')
var ($nam,$dom) = split('\.',$hst,2)
if testFile('x','/bin/domainname')
 var ($nis) = command('/bin/domainname')
if testFile('r','/etc/resolv.conf')
 var $dns = field('\s+',1,grepFile('/etc/resolv.conf','domain'))
if testFile('x','/usr/bin/nslookup')
{if $nam
  var $nsl = field(concat(quote($nam),'\.'),1,\
                   grepCommand(concat('/usr/bin/nslookup ',$hst),'Name','f'))
 else
  var $nsl = field(concat(quote($hst),'\.'),1,\
                   grepCommand(concat('/usr/bin/nslookup ',$hst),'Name','f'))
}
call setHcveResult(cond($dom,$dom,\
                        $nis,$nis,\
                        $dns,$dns,\
                        $nsl,$nsl,\
                            'NotFound'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule gets the host domain name.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A01110" mode="RECORD" name="IP Address">
<sdp_command type="RDA"><![CDATA[var ($hst) = command('hostname')
var @lst = grepCommand(concat('/usr/sbin/ping -c 1 ',$hst),'.')
call setHcveResult(replace(field('\s+',3,grep(@lst,'\d+:','f')),':'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule gets the host IP address.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A01120" mode="VERIFY" name="Format /etc/hosts OK?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A01100" minimum="RECORD" result="FAILED">
<![CDATA[Needs domain name.]]>
</sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
if !testFile('r','/etc/hosts')
 return setHcveResult('Cannot access /etc/hosts')
if !@tbl = grepFile('/etc/hosts',\
  concat('^([^\s\#]+\s+)+',quote(${RDA.HOST}),\
         '\s+([^\s\#]+\s+)*',quote(${RDA.NODE}),'(\s|\z|\#)'))
 return setHcveResult('no entry found')

# Test that line begins with IPv4 IP address
if grep(@tbl,'^(\d{1,3}\.){3}\d{1,3}\s','f')
 return setHcveResult('Adequate IPv4 entry')

# Tests that line begins with IPv6 IP address, first that all eight groups are populated, then situations where groups that are all zero are omitted (two colons together).
if grep(@tbl,'^([A-F\d]{1,4}(:[A-F\d]{1,4}){7}\s|\
                :(:[A-F\d]{1,4}){1,6}\s|\
                ([A-F\d]{1,4}:){1,5}(:[A-F\d]{1,4}){1,5}\s|\
                ([A-F\d]{1,4}:){1,6}:\s)','f')
 return setHcveResult('Adequate IPv6 entry')
return setHcveResult('no correct entry found')
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the ``/etc/hosts`` file contains a line with ``ip_address fully_qualified_domainname short_hostname``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="^Adequate" result="PASSED"><![CDATA[The ``/etc/hosts`` entry for the fully qualified domain name and host name is adequate.]]></sdp_action>
<sdp_action condition="==" minimum="Cannot access /etc/hosts" result="FAILED"><![CDATA[Grant read permissions on ``/etc/hosts`` to the current user.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The fully qualified host name and host name are not configured correctly. Ensure that there is an IP address entry for the fully qualified domain name with the host name as one of the aliases.
|*Return Value*|*Action"|
|no entry found|No entry with the fully qualified domain name followed by the host name was found.|
|no correct entry found|No entry beginning with an IP address with the fully qualified domain name followed by the host name was found.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01130" mode="VERIFY" name="DHCP Client Check?">
<sdp_command type="RDA"><![CDATA[call setHcveResult(cond(\
 grepCommand('ps -leaf','dhcpagent','f'),'Possible dhcpagent daemon running',\
                                         'dhcpagent daemon not running'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the server is running DHCP client (dhcpagent daemon). DHCP clients are not supported.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="dhcpagent daemon not running" result="PASSED"><![CDATA[This server is not using a DHCP client. No action required.]]></sdp_action>
<sdp_action result="FAILED"><![CDATA[DHCP clients are not supported. You must use a static IP address and host name.]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01140" mode="VERIFY" name="DNS Lookup?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A01110" minimum="RECORD" result="FAILED"><![CDATA[Needs IP address.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var $ip = "%A01110%"
var $hst = field('\.',0,command('hostname'))
call setHcveResult(cond(\
  not(length($ip)),\
    'Cannot determine IP address',\
  not(testFile('x','/usr/bin/nslookup')),\
    'Cannot access /usr/bin/nslookup',\
  and(grepCommand(concat('/usr/bin/nslookup ',$hst),quote($ip),'f'),\
      grepCommand(concat('/usr/bin/nslookup ',$ip),quote($hst),'f')),\
    'Host correctly registered in DNS',\
    'Host not correctly registered in DNS'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the host is registered correctly in the DNS.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Host correctly registered in DNS" result="PASSED"><![CDATA[The host is registered correctly in the DNS.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Host not correctly registered in DNS|Register the host.domain in the DNS.|
|Cannot determine IP address|Fix any problem with the host IP address.|
|Cannot access /usr/bin/nslookup|Grant execute permissions on ``/usr/bin/nslookup`` to the user who is logged in.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01150" mode="VERIFY" name="Host Name Length?">
<sdp_command type="RDA"><![CDATA[var $hst = uname('n')
call setHcveResult(cond(\
  expr('>',length($hst),255),'Host name is greater than 255 characters',\
                             'Host name is less than 255 characters'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that your fully qualified host name is not longer than 255 characters.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Host name is less than 255 characters" result="PASSED"><![CDATA[The host name is less than 255 characters. No action required.]]></sdp_action>
<sdp_action result="FAILED"><![CDATA[Modify your fully qualified host name to less than 255 characters.]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01160" mode="VERIFY" name="Port 1521 Available?">
<sdp_command type="RDA"><![CDATA[var @lst = grepCommand('/bin/netstat -an','LISTEN')
if !grep(@lst,'1521','f')
 return setHcveResult('Free')
if testFile('x','/usr/sbin/lsof')
 var ($prc) = grepCommand('/usr/sbin/lsof -i TCP:1521','LIST','f')
elsif testFile('x','/usr/bin/lsof')
 var ($prc) = grepCommand('/usr/bin/lsof -i TCP:1521','LIST','f')
elsif testFile('x','/usr/local/bin/lsof')
 var ($prc) = grepCommand('/usr/local/bin/lsof -i TCP:1521','LIST','f')
else
 return setHcveResult('Cannot use lsof')
if !length($prc)
 return setHcveResult('Cannot use lsof')
macro chk_tns
{var ($prc) = @arg
 var @cmd = grepCommand('ps -ef',field('\s+',1,$prc))
 var @ver = command(replace(field(\
    '\s+',8,grep(@cmd,'tnslsnr','f')),'tnslsnr','lsnrctl version'))
 var $ver = field('\s+',6,grep(@ver,'LSNRCTL','f'))
 return cond(compare('older',$ver,'10.1.0.2.0'),\
             concat('TNS Listener version [',$ver,'] is running'),\
             'TNS Listener 10.1.0.2.0 or later is running')
}
call setHcveResult(cond(not(match(field('\s+',0,$prc),'tnslsnr',true)),\
                        'Port is used by non-Oracle program',\
                        chk_tns($prc)))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that port 1521 is free. If an Oracle listener version 9.0.1 or later uses port 1521, then the existing database and the Oracle Application Server 10g Metadata Repository will use the existing listener. The installer performs this configuration automatically. If an Oracle listener version earlier than 9.0.1 uses port 1521, then the existing listener must be stopped. After the installation is complete, you can configure the new 9.0.1 listener to listen to the existing (pre 9.0.1) databases. If non-Oracle programs use port 1521, then this program must be configured to listen to ports other than 1521. For more information, see the "If Port 1521 is in Use" section of the ''Oracle Application Server 10g Installation Guide''.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="TNS Listener 10.1.0.2.0 or later is running|Free" result="PASSED"><![CDATA[Port 1521 is not used or is used by TNS Listener version 10.1.0.2.0 or later.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|TNS Listener version ... is running|Stop the existing listener.|
|Port is used by non-Oracle program|Reconfigure the program to use a different port than 1521.|
|Cannot use lsof|Check port 1521 manually.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01170" mode="VERIFY" name="Oracle Home Length?">
<sdp_command type="RDA"><![CDATA[var $ORACLE_HOME = getEnv('ORACLE_HOME')
call setHcveResult(cond(\
  not(defined($ORACLE_HOME)),\
    'ORACLE_HOME is not set',\
  expr('<=',length($ORACLE_HOME),127),\
    'Less than 127 char',\
    'Longer than 127 characters'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the path to the Oracle home directory is not longer than 127 characters.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Less than 127 char" result="PASSED"><![CDATA[The Oracle home directory is not longer than 127 characters.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Longer than 127 characters|Change ORACLE_HOME to a directory not longer than 127 characters.|
|ORACLE_HOME is not set|Set the ORACLE_HOME environment variable.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01200" mode="VERIFY" name="ulimits OK?">
<sdp_command type="RDA"><![CDATA[var @tbl =()
macro get_ulimit_unl
{var (\@tbl,$nam) = @arg
 var $lmt = field('\s+',1,grepLastFile(concat('^',$nam,'\('),'if'))
 if !defined($lmt)
  call push(@tbl,concat($nam,'NotDefined'))
 elsif compare('ne',$lmt,'unlimited')
  call push(@tbl,concat($nam,'TooSmall'))
}
call loadCommand('/usr/bin/ulimit -a')
call get_ulimit_unl(\@tbl,'File')
call get_ulimit_unl(\@tbl,'Time')
call get_ulimit_unl(\@tbl,'Data')
call get_ulimit_unl(\@tbl,'Stack')
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'ulimitOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the ``ulimit`` settings are adequate for installing Oracle Application Server 10g (10.1.4.0.1).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="ulimitOK" result="PASSED"><![CDATA[The ``ulimit`` settings are adequate. No action required.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Review the ``ulimit`` settings and check the recommended values from the ${'BOOK} before installing the software.
|*Return Value*|*Action*|
|FileNotDefined|ulimit(FILE) is not defined|
|FileTooSmall|Increase the ulimit(FILE) to unlimited|
|TimeNotDefined|ulimit(TIME) is not defined|
|TimeTooSmall|Increase the ulimit(TIME) to unlimited|
|DataNotDefined|ulimit(DATA) is not defined|
|DataTooSmall|Increase the ulimit(DATA) to unlimited|
|StackNotDefined|ulimit(STACK) is not defined|
|StackTooSmall|Increase the ulimit(STACK) to unlimited|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01210" mode="VERIFY" name="NLS_LANG Defined?">
<sdp_command type="RDA"><![CDATA[var $env = getEnv('NLS_LANG')
call setHcveResult(cond(\
  not(defined($env)),\
    'Not set',\
  match($env,'american_america',true),\
    'Set properly',\
    'Not set properly'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the ``NLS_LANG`` environment variable is defined. If it is defined, then it must be set to ``American_America``, otherwise the Oracle Internet Directory (OID) Configuration Assistant will fail.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="Not set|Set properly" result="PASSED"><![CDATA[The ``NLS_LANG`` environment variable is set properly or is not set.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Not set properly|Set the ``NLS_LANG`` environment variable to ``AMERICAN_AMERICA.&lt;characterset&gt;``|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01220" mode="VERIFY" name="Monitor Colors">
<sdp_command type="RDA"><![CDATA[call loadCommand('/usr/X11R6/bin/xdpyinfo 2>&1')
var @dpt = grepLastFile('depths')
call setHcveResult(cond(\
  grep(@dpt,'8','f'),             'Adequate',\
  not(defined(getEnv('DISPLAY'))),'DISPLAY is not set',\
  grepLastFile('unable','f'),     'Cannot open DISPLAY',\
                                  'Need at least 256 colors'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the monitor has a minimum of 256 colors.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Adequate" result="PASSED"><![CDATA[The monitor has enough colors.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 256 colors|Use a display with at least 256 colors. Several components or X-Windows programs could require it unless you have already deployed workarounds for each of them.|
|DISPLAY is not set|Set the DISPLAY environment variable to a valid display. Several components or X-Windows programs could require it unless you have already deployed workarounds for each of them.|
|Cannot open DISPLAY|Set the DISPLAY environment variable to a correct display. Several components or X-Windows programs could require it unless you have already deployed workarounds for each of them.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

</sdp_group>
</sdp_content>
</sdp_diaglet>
