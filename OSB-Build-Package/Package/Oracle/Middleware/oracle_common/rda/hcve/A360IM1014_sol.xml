<sdp_diaglet platform="solaris" product="IM1014" set="A360IM1014_sol" title="Oracle Identity Management 10g (10.1.4) Preinstall (Solaris)" type="A">
<sdp_meta type="version" id="$Id: A360IM1014_sol.xml,v 1.12 2012/04/18 16:38:46 mschenke Exp $"/>
<sdp_meta author="JCR" change="Improve Temp Space check" date="20120406" type="history"/>
<sdp_content set="A360IM1014_sol" title="Oracle Identity Management 10g (10.1.4) Preinstall (Solaris)" type="check">
<sdp_group>

<sdp_rule id="A00010" mode="RECORD" name="OS">
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$OS_NAM,$OS_VER,$OS_BIT
var $BOOK = undef
call setHcveVariable('$BOOK')
if match($OS_ARC,'Sparc')
 var $BOOK = 'Oracle Application Server Installation Guide 10g (10.1.4.0.1) \
              for Solaris Operating System (SPARC 64-bit)'
elsif match($OS_ARC,'Intel')
 var $BOOK = 'Oracle Application Server Installation Guide 10g (10.1.4.0.1) \
              for Solaris Operating System (x86) and Solaris Operating System \
              (x86-64)'
call setHcveResult(concat($OS_ARC,' ',$OS_NAM,' ',$OS_VER,' ',$OS_BIT,'-bit'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule retrieves the operating system (OS) description.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A00020" mode="VERIFY" name="Processor Type OK?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','/usr/sbin/psrinfo')
 return setHcveResult('Cannot access /usr/sbin/psrinfo')
elsif grepCommand('/usr/sbin/psrinfo -v','sparcv9','if')
 return setHcveResult('SPARC v9')
elsif grepCommand('/usr/sbin/psrinfo -v','i386','if')
 return setHcveResult('i386')
elsif grepCommand('/usr/sbin/psrinfo -v','sparcv8','if')
 return setHcveResult('SPARC v8')
else
 return setHcveResult('Not approved processor')]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks for the processor type. The processor must have a SPARC v9 or i386 architecture.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="SPARC v9" result="PASSED">
<![CDATA[The processor is an approved type.]]>
</sdp_action>
<sdp_action condition="==" minimum="i386" result="PASSED">
<![CDATA[The processor is an approved type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Not approved processor|The processor must have a SPARC v9 or i386 architecture.|
|Cannot access /usr/sbin/psrinfo|Grant execute permissions on ``/usr/sbin/psrinfo`` to the user who is logged in.|
|SPARC v8|The processor must have a SPARC v9 architecture. This is due to the usage of Sun Java 1.4.1 HotSpot Server VM, which does not support SPARC v8 and older processors.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00030" mode="VERIFY" name="Processor Speed OK?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','/usr/sbin/psrinfo')
 return setHcveResult('Cannot access /usr/sbin/psrinfo')
var ($lin) = grepCommand('/usr/sbin/psrinfo -v','processor operates at','f')
var $mhz = field('\s+',5,$lin)
call setHcveResult(cond(\
 expr('>=',$mhz,450),\
   'Processor speed is adequate.',\
   concat('Processor speed [',$mhz,'MHZ] does not meet minimum requirement')))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks the processor speed. The requirement is 450 MHz or faster.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Processor speed is adequate." result="PASSED">
<![CDATA[The minimum requirement for the processor speed is met.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Processor speed ... does not meet minimum requirement|Use a processor with a speed of 450 MHz or faster.|
|Cannot access /usr/sbin/psrinfo|Grant execute permissions on ``/usr/sbin/psrinfo`` to the user who is logged in.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00110" mode="VERIFY" name="OS OIMgr Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$OS_VER,$OS_BIT
call setHcveResult(cond(\
  and(match($OS_VER,'^2\.(9|10)$'),match($OS_BIT,'64'),match($OS_ARC,'Sparc')),\
      'Certified','Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Identity Manager (OIMgr).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Identity Manager.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Identity Manager. The Solaris operating systems certified for Oracle Identity Manager are:
Solaris 9 SPARC 64-bit, Solaris 10 SPARC 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00120" mode="VERIFY" name="OS OIF Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$OS_VER,$OS_BIT
if and(match($OS_ARC,'Intel'),not(testFile('x','/usr/sbin/prtconf')))
 return setHcveResult('No Access')
call setHcveResult(cond(\
  and(match($OS_ARC,'Intel'),match($OS_VER,'^2\.10$'),\
    grepCommand('/usr/sbin/prtconf -v','AMD Opteron','f')),'Certified',\
  and(match($OS_ARC,'Intel'),match($OS_VER,'^2\.(9|10)$'),match($OS_BIT,'32'),\
    grepCommand('/usr/sbin/prtconf -v','Intel','f')),\
                                                        'Certified',\
  and(match($OS_ARC,'Sparc'),match($OS_VER,'^2\.(8|9|10)$'),\
      match($OS_BIT,'64')),                             'Certified',\
  'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Identity Federation (OIF).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Identity Federation.]]>
</sdp_action>
<sdp_action condition="==" minimum="No Access" result="FAILED">
<![CDATA[Grant execute permissions on ``/usr/sbin/prtconf`` to the user who is logged in.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Identity Federation. The certified Solaris operating systems for Oracle Identity Federation are:
Solaris 8 SPARC 32-bit, Solaris 9 SPARC 32-bit, Solaris 9 x86 32-bit, Solaris 10 SPARC 32-bit, Solaris 10 x86 32-bit, Solaris 10 x86 on AMD Opteron 32-bit, Solaris 10 x86 on AMD Opteron 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00130" mode="VERIFY" name="OS OAM Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$OS_VER,$OS_BIT
call setHcveResult(cond(\
  and(match($OS_VER,'^2\.(8|9|10)$'),match($OS_BIT,'64'),\
      match($OS_ARC,'Sparc')),'Certified',\
                              'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Access Manager.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Access Manager.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Access Manager. The certified Solaris operating systems for Oracle Access Manager are:
Solaris 8 SPARC 64-bit, Solaris 9 SPARC 64-bit, Solaris 10 SPARC 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00140" mode="VERIFY" name="OS OVD Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_BIT,$OS_ARC
call setHcveResult(cond(\
  and(match($OS_VER,'^2\.(9|10)$'),match($OS_BIT,'32'),match($OS_ARC,'Sparc')),\
      'Certified',\
  'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Virtual Directory (OVD).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Virtual Directory.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Virtual Directory. The certified Solaris operating systems for Oracle Virtual Directory are:
Solaris 9 SPARC 32-bit, Solaris 10 SPARC 32-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00150" mode="VERIFY" name="OS ORM Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_BIT,$OS_ARC
call setHcveResult(cond(\
  and(match($OS_VER,'^2\.10$'),match($OS_BIT,'64'),match($OS_ARC,'Sparc')),\
      'Certified',\
  'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Role Manager (ORM).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Role Manager.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Role Manager. The certified Solaris operating systems for Oracle Role Manager is:
Solaris 10 SPARC 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00160" mode="VERIFY" name="OS OAAM Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_BIT,$OS_ARC
call setHcveResult(cond(\
  and(match($OS_VER,'^2\.10$'),match($OS_BIT,'64'),match($OS_ARC,'Sparc')),\
      'Certified',\
  'Not Certified'))
]]></sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Adaptive Access Manager.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Adaptive Access Manager.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Adaptive Access Manager (OAAM). The certified Solaris operating systems for Oracle Adaptive Access Manager is:
Solaris 10 SPARC 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00170" mode="VERIFY" name="OS OID and SSO Certified?">
<sdp_command type="RDA"><![CDATA[import $OS_VER,$OS_BIT,$OS_ARC
if and(match($OS_VER,'Intel'),not(testFile('x','/usr/sbin/prtconf')))
 return setHcveResult('No access')
call setHcveResult(cond(\
  and(match($OS_ARC,'Intel'),match($OS_VER,'^2\.10$'),\
    grepCommand('/usr/sbin/prtconf -v','Opteron','f')),'Certified',\
  and(match($OS_ARC,'Intel'),match($OS_VER,'^2\.(9|10)$'),match($OS_BIT,'32'),\
    grepCommand('/usr/sbin/prtconf -v','Intel','f')),\
                                                        'Certified',\
  and(match($OS_ARC,'Sparc'),match($OS_VER,'^2\.(8|9|10)$'),\
      match($OS_BIT,'64')),                             'Certified',\
  'Not Certified'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks if the operating system is certified for Oracle Internet Directory (OID) and Oracle Application Server Single Sign-On(SSO).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Certified" result="PASSED">
<![CDATA[The operating system is certified for Oracle Internet Directory and Oracle Application Server Single Sign-On.]]></sdp_action>
<sdp_action condition="==" minimum="No Access" result="FAILED">
<![CDATA[Grant execute permissions on ``/usr/sbin/prtconf`` to the user who is logged in.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[The operating system is not certified for Oracle Internet Directory and Oracle Application Server Single Sign-On. The certified Solaris operating systems for Oracle Internet Directory and Oracle Application Server Single Sign-On are:
Solaris 8 SPARC 64-bit, Solaris 9 SPARC 64-bit, Solaris 9 x86 32-bit, Solaris 10 SPARC 64-bit, Solaris 10 x86 32-bit, Solaris 10 x86 on AMD Opteron 32-bit, Solaris 10 x86 on AMD Opteron 64-bit]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00200" mode="RECORD" name="Total Memory">
<sdp_command type="RDA"><![CDATA[var $MEM = undef
call setHcveVariable('$MEM')
if !testFile('x','/usr/sbin/prtconf')
 return setHcveResult('Cannot access /usr/sbin/prtconf')
var $MEM = field('\s+',2,grepCommand('/usr/sbin/prtconf','Memory','f'))
call setHcveResult(concat($MEM,' MB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule retrieves the available physical memory in MB.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A00300" mode="Verify" name="Memory MDR and OIM OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required"><![CDATA[This rule needs amount of physical memory.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,1024),'Available',\
                       'Need at least 1 GB'))
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Application Server Metadata Repository (MDR) and Oracle Identity Management (OIM) installation type. The minimum requirement is 1 GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Application Server Metadata Repository and Oracle Identity Management installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1 GB|Increase the memory to 1 GB or more to install the Oracle Application Server Metadata Repository and Oracle Identity Management installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00310" mode="VERIFY" name="Memory OIM OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required"><![CDATA[This rule needs amount of physical memory.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,1024),'Available',\
                       'Need at least 1 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Identity Management only installation type. The minimum requirement is 1 GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Identity Management only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1 GB|Increase the memory to 1 GB or more to install the Oracle Identity Management only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00320" mode="VERIFY" name="Memory MDR OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required"><![CDATA[This rule needs amount of physical memory.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,1024),'Available',\
                       'Need at least 1 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Application Server Metadata Repository (MDR) only installation type. The minimum requirement is 1 GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Application Server Metadata Repository only installation type.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1 GB|Increase the memory to 1 GB or more to install the Oracle Application Server Metadata Repository only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00330" mode="VERIFY" name="Memory OIF OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00200" minimum="MB$" result="FAILED" value="Physical memory size required"><![CDATA[This rule needs amount of physical memory.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $MEM
call setHcveResult(cond(\
  expr('>=',$MEM,512),'Available',\
                      'Need at least 512 MB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough memory to install the Oracle Identity Federation (OIF) only installation type. The minimum requirement is 512 MB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough memory to install the Oracle Identity Federation only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 512 MB|Increase the memory to 512 MB or more to install the Oracle Identity Federation only installation type.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00400" mode="VERIFY" name="Temp Space OK?">
<sdp_command type="RDA"><![CDATA[import $OS_ARC
call setHcveVariable('$MIN_TEMP')
if match($OS_ARC,'Intel')
{var $min = '409600'
 var $MIN_TEMP = '400 MB'
}
elsif match($OS_ARC,'Sparc')
{var $min = '256000'
 var $MIN_TEMP = '250 MB'
}
else
 call setHcveResult('Inappropriate processor')
var ($flg,$tmp,@tbl) = (true,{'/tmp','/tmp'})
if getEnv('TMP')
 var $tmp->{'TMP'} = last
loop $key (keys(%tmp))
{if !testDir('d',$tmp->{$key})
  call push(@tbl,concat($key,' invalidDir'))
 else
 {if !testDir('w',$tmp->{$key})
   call push(@tbl,concat($key,' NoWrite'))
  if and($flg,expr('>=',get_df($tmp->{$key}),$min))
   var $flg = false
 }
}
if $flg
{loop $key (keys(%tmp))
  call push(@tbl,concat($key,' tooSmall'))
}
call setHcveParameter('RULE.A00400',$tmp)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'TempSpaceOK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough temporary space for installing. Oracle Universal Installer (OUI) initially checks the ``TMP`` and ``TMPDIR`` environment variables to locate the temporary directory. If these environment variables do not exist, then OUI uses ``/tmp``. The minimum requirement is 400 MB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="TempSpaceOK" result="PASSED">
<![CDATA[The system has enough temporary space.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|/tmp invalidDir|ALERT - ``/tmp`` is not a valid directory. ``/tmp`` needs to be a directory.|
|/tmp NoWrite|ALERT - The user does not have write permissions to the ``/tmp`` directory.|
|/tmp tooSmall|ALERT - There is less than the needed 400 MB of free space in the ``/tmp`` directory.|
|TMP invalidDir|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, ${`RULE.A00400.TMP} is an invalid directory. Take appropriate action.|
|TMP NoWrite|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, the user does not have write permissions to ${`RULE.A00400.TMP}.|
|TMP tooSmall|ALERT - ``TMP`` is set to ${`RULE.A00400.TMP} in the environment; however, ${`RULE.A00400.TMP} has less than the required ${MIN_TEMP} of free space. Make sure your temporary space has at least ${MIN_TEMP} of free space.|
|Inappropriate processor|The processor must be either Intel or SPARC.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00410" mode="VERIFY" name="Swap space OK?">
<sdp_command type="RDA"><![CDATA[if !testFile('x','/usr/sbin/swap')
 return setHcveResult('Cannot access /usr/sbin/swap')
var $siz = field('\s+',10,grepCommand('/usr/sbin/swap -s','.','f'))
var $siz = field('\s+',0,replace($siz,'k',' k '))
var $siz = expr('/',$siz,1048576)
call setHcveResult(cond(\
  expr('>=',$siz,1.5),'Available',\
                      'Need at least 1.5 GB'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough swap space. The minimum requirement is 1.5 GB.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough swap space.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 1.5 GB|Increase the swap space to 1.5 GB or more.|
|Cannot access /usr/sbin/swap|Grant execute permissions on ``/usr/sbin/swap`` to the user who is logged in.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00420" mode="RECORD" name="Disk Space">
<sdp_command type="RDA"><![CDATA[var $ORACLE_HOME = getEnv('ORACLE_HOME')
var $DU = cond(\
  not($ORACLE_HOME),              'ORACLE_HOME is not set',\
  not(testDir('d',$ORACLE_HOME)), 'Cannot access ORACLE_HOME',\
                                  get_df($ORACLE_HOME))
call setHcveVariable('$DU')
call setHcveResult(cond(isNumber($DU),concat($DU,' KB'),$DU))]]>
</sdp_command>
<sdp_description><![CDATA[The rule retrieves the available disk space.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A00500" mode="VERIFY" name="Disk space Infra OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required"><![CDATA[This rule needs available disk space.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  match($OS_ARC,'Sparc'),cond(expr('>=',$dsk,4.83),'Available','Need 4.83 GB'),\
  match($OS_ARC,'Intel'),cond(expr('>=',$dsk,4.2) ,'Available','Need 4.2 GB'),\
                         'Inappropriate processor'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Infrastructure installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Infrastructure installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 4.83 GB|Increase the available space to 4.83 GB or more to install the Infrastructure installation type.|
|Need 4.2 GB|Increase the available space to 4.2 GB or more to install the Infrastructure installation type.|
|Inappropriate processor|The processor must be either Intel or SPARC.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00510" mode="VERIFY" name="Disk space OIMgr OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required"><![CDATA[This rule needs available disk space.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  match($OS_ARC,'Sparc'),cond(expr('>=',$dsk,2.27),'Available','Need 2.27 GB'),\
  match($OS_ARC,'Intel'),cond(expr('>=',$dsk,1.6) ,'Available','Need 1.6 GB'),\
                         'Inappropriate processor'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Identity Manager (OIMgr) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Identity Manager only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 2.27 GB|Increase the available space to 2.27 GB or more to install the Oracle Identity Manager only installation type.|
|Need 1.6 GB|Increase the available space to 1.6 GB or more to install the Oracle Identity Manager only installation type.|
|Inappropriate processor|The processor must be either Intel or SPARC.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00520" mode="VERIFY" name="Disk space MDR OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required"><![CDATA[This rule needs available disk space.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$DU
var $dsk = expr('/',$DU,1048576)
call setHcveResult(cond(\
  match($OS_ARC,'Sparc'),cond(expr('>=',$dsk,4.83),'Available','Need 4.83 GB'),\
  match($OS_ARC,'Intel'),cond(expr('>=',$dsk,4.2) ,'Available','Need 4.2 GB'),\
                         'Inappropriate processor'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Application Server Metadata Repository (MDR) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Application Server Metadata Repository only installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 4.83 GB|Increase the available space to 4.83 GB or more to install the Oracle Application Server Metadata Repository only installation type.|
|Need 4.2 GB|Increase the available space to 4.2 GB or more to install the Oracle Application Server Metadata Repository only installation type.|
|Inappropriate processor|The processor must be either Intel or SPARC.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00530" mode="VERIFY" name="Disk space OIF OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00420" minimum="KB$" result="FAILED" value="Amount of available disk space required"><![CDATA[This rule needs available disk space.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import $OS_ARC,$DU
var $dsk = expr('/',$DU,1024)
call setHcveResult(cond(\
  match($OS_ARC,'Sparc'),cond(expr('>=',$dsk,1024),'Available','Need 1 GB'),\
  match($OS_ARC,'Intel'),cond(expr('>=',$dsk,700) ,'Available','Need 700 MB'),\
                         'Inappropriate processor'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the system has enough disk space to install the Oracle Identity Federation (OIF) only installation type.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Available" result="PASSED">
<![CDATA[The system has enough disk space to install the Oracle Identity Federation installation type.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need 1 GB|Increase the available space to 1 GB or more to install the Oracle Identity Federation installation type.|
|Need 700 MB|Increase the available space to 700 MB or more to install the Oracle Identity Federation installation type.|
|Inappropriate processor|The processor must be either Intel or SPARC.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00600" mode="VERIFY" name="Solaris 9 x86 Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Intel SunOS 2.9" result="SKIPPED" value="Not on Solaris 9 x86"><![CDATA[This rule applies to Solaris 9 x86 only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !loadCommand('/usr/bin/showrev -p')
 return setHcveResult('NoAccess')
macro check_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {var ($flg,$err) = (true)
  var ($pch_num,$pch_lvl) = split('\-',$pch)
  if grepLastFile($pch_num,'f')
  {var %srt = ()
   if grepLastFile(concat('Patch: ',$pch_num,'\-'))
   {loop $key (last)
     var $srt{$key} = true
    var $pch_rev = field('\s+',1,keys(%srt,'KD'))
    next compare('ge',replace($pch_rev,'\-'),replace($pch,'\-'))
    var $err = concat('Patch [',$pch_rev,'] must be at level [',$pch,']')
   }
   loop $lin (grepLastFile(concat('Obsoletes:.*',$pch_num,'.*Requires:')))
   {var ($lvl) = match($lin,concat('.*Obsoletes:.*?',$pch_num,'\-(\d+)'))
    if compare('ge',$lvl,$pch_lvl)
    {var $flg = false
     break
    }
   }
   if $flg
    call push(@tbl,nvl($err,concat('Patch [',$pch_num,'] is not installed')))
  }
  else
   call push(@tbl,concat('Patch [',$pch_num,'] is not installed'))
 }
}
call loadCommand('/usr/bin/showrev -p')
call check_patch(\@tbl,'111713-06','111728-03','112234-12','113986-10',\
                       '115114-02','116013-02')
call setHcveResult(cond(\
  scalar(@tbl),concat('Patches [',join(' ',@tbl),'] are missing'),\
               'All required patches installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches (or later) for Solaris 9 x86 are installed. The required patches for Solaris 9 :
111713-06, 111728-03, 112234-12, 113986-10, 115114-02, 116013-02]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED">
<![CDATA[All required operating system patches are installed.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Patches ... are missing|Install the listed missing patches.|
|NoAccess|You do not have access to ``/usr/bin/showrev``|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00610" mode="VERIFY" name="Solaris 10 x86 Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Intel SunOS 2.10" result="SKIPPED" value="Not on Solaris 10 x86"><![CDATA[This rule applies to Solaris 10 x86 only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !loadCommand('/usr/bin/showrev -p')
 return setHcveResult('NoAccess')
macro check_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {var ($flg,$err) = (true)
  var ($pch_num,$pch_lvl) = split('\-',$pch)
  if grepLastFile($pch_num,'f')
  {var %srt = ()
   if grepLastFile(concat('Patch: ',$pch_num,'\-'))
   {loop $key (last)
     var $srt{$key} = true
    var $pch_rev = field('\s+',1,keys(%srt,'KD'))
    next compare('ge',replace($pch_rev,'\-'),replace($pch,'\-'))
    var $err = concat('Patch [',$pch_rev,'] must be at level [',$pch,']')
   }
   loop $lin (grepLastFile(concat('Obsoletes:.*',$pch_num,'.*Requires:')))
   {var ($lvl) = match($lin,concat('.*Obsoletes:.*?',$pch_num,'\-(\d+)'))
    if compare('ge',$lvl,$pch_lvl)
    {var $flg = false
     break
    }
   }
   if $flg
    call push(@tbl,nvl($err,concat('Patch [',$pch_num,'] is not installed')))
  }
  else
   call push(@tbl,concat('Patch [',$pch_num,'] is not installed'))
 }
}
call loadCommand('/usr/bin/showrev -p')
call check_patch(\@tbl,'118345-03','119961-02')
call setHcveResult(cond(\
  scalar(@tbl),concat('Patches [',join(' ',@tbl),'] are missing'),\
               'All required patches installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches (or later) for Solaris 10 x86 are installed. The required patches are:
118345-03, 119961-02.]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED">
<![CDATA[All required operating system patches are installed.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Not Certified OS|You must use one of the listed certified operating systems.|
|Patches ... are missing|Install the listed missing patches.|
|NoAccess|You do not have access to ``/usr/bin/showrev``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00620" mode="VERIFY" name="Solaris 8 SPARC Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.8" result="SKIPPED" value="Not on Solaris 8 SPARC"><![CDATA[This rule applies to Solaris 8 SPARC only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !loadCommand('/usr/bin/showrev -p')
 return setHcveResult('NoAccess')
macro check_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {var ($flg,$err) = (true)
  var ($pch_num,$pch_lvl) = split('\-',$pch)
  if grepLastFile($pch_num,'f')
  {var %srt = ()
   if grepLastFile(concat('Patch: ',$pch_num,'\-'))
   {loop $key (last)
     var $srt{$key} = true
    var $pch_rev = field('\s+',1,keys(%srt,'KD'))
    next compare('ge',replace($pch_rev,'\-'),replace($pch,'\-'))
    var $err = concat('Patch [',$pch_rev,'] must be at level [',$pch,']')
   }
   loop $lin (grepLastFile(concat('Obsoletes:.*',$pch_num,'.*Requires:')))
   {var ($lvl) = match($lin,concat('.*Obsoletes:.*?',$pch_num,'\-(\d+)'))
    if compare('ge',$lvl,$pch_lvl)
    {var $flg = false
     break
    }
   }
   if $flg
    call push(@tbl,nvl($err,concat('Patch [',$pch_num,'] is not installed')))
  }
  else
   call push(@tbl,concat('Patch [',$pch_num,'] is not installed'))
 }
}
call loadCommand('/usr/bin/showrev -p')
call check_patch(\@tbl,'108652-82','108921-21','108940-62','108773-18',\
                       '111310-01','109147-28','111308-04','112438-03',\
                       '108434-17','108435-17','111111-04','112396-02',\
                       '110386-03','111023-03','111317-05','113648-03',\
                       '115827-01','116602-01','108987-13','108528-29',\
                       '108989-02','108993-36','109326-14','110615-11')
call setHcveResult(cond(\
  scalar(@tbl),concat('Patches [',join(' ',@tbl),'] are missing'),\
               'All required patches installed'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches (or later) for Solaris 8 SPARC are installed. The required patches are:
108652-82, 108921-21, 108940-62, 108773-18, 111310-01, 109147-28, 111308-04, 
112438-03, 108434-17, 108435-17, 111111-04, 112396-02, 110386-03, 111023-03, 
111317-05, 113648-03, 115827-01, 116602-01, 108987-13, 108528-29, 108989-02, 
108993-36, 109326-14, 110615-11.]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED">
<![CDATA[All required operating system patches are installed.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Patches ... are missing|Install the listed missing patches.|
|NoAccess|You do not have access to ``/usr/bin/showrev``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00630" mode="VERIFY" name="Solaris 9 SPARC Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.9" result="SKIPPED" value="Not on Solaris 9 SPARC"><![CDATA[This rule applies to Solaris SPARC 9 only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
if !loadCommand('/usr/bin/showrev -p')
 return setHcveResult('NoAccess')
macro check_patch
{var (\@tbl,@pch) = @arg
 loop $pch (@pch)
 {var ($flg,$err) = (true)
  var ($pch_num,$pch_lvl) = split('\-',$pch)
  if grepLastFile($pch_num,'f')
  {var %srt = ()
   if grepLastFile(concat('Patch: ',$pch_num,'\-'))
   {loop $key (last)
     var $srt{$key} = true
    var $pch_rev = field('\s+',1,keys(%srt,'KD'))
    next compare('ge',replace($pch_rev,'\-'),replace($pch,'\-'))
    var $err = concat('Patch [',$pch_rev,'] must be at level [',$pch,']')
   }
   loop $lin (grepLastFile(concat('Obsoletes:.*',$pch_num,'.*Requires:')))
   {var ($lvl) = match($lin,concat('.*Obsoletes:.*?',$pch_num,'\-(\d+)'))
    if compare('ge',$lvl,$pch_lvl)
    {var $flg = false
     break
    }
   }
   if $flg
    call push(@tbl,nvl($err,concat('Patch [',$pch_num,'] is not installed')))
  }
  else
   call push(@tbl,concat('Patch [',$pch_num,'] is not installed'))
 }
}
call loadCommand('/usr/bin/showrev -p')
call check_patch(\@tbl,'113096-03','112785-35')
call setHcveResult(cond(\
  scalar(@tbl),concat('Patches [',join(' ',@tbl),'] are missing'),\
               'All required patches installed'))
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches (or later) for Solaris 9 SPARC are installed. The required patches are:
113096-03, 112785-35]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All required patches installed" result="PASSED">
<![CDATA[All required operating system patches are installed.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Patches ... are missing|Install the listed missing patches.|
|NoAccess|You do not have access to ``/usr/bin/showrev``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A00640" mode="VERIFY" name="Solaris 10 SPARC Patches OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.10" result="SKIPPED" value="Not on Solaris 10 SPARC"><![CDATA[This rule applies to Solaris 10 SPARC only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[call setHcveResult('No OS patches required')]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the necessary operating system patches (or later) for Solaris 10 SPARC are installed. No patches are required.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="No OS patches required" result="PASSED">
<![CDATA[No operating system patches are required.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Patches ... are missing|Install the listed missing patches.|
|NoAccess|You do not have access to ``/usr/bin/showrev``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01000" mode="VERIFY" name="Solaris 9 x86 Params OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Intel SunOS 2.9" result="SKIPPED" value="Not on Solaris 9 x86"><![CDATA[This rule applies to Solaris 9 x86 only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
var $SEMMNI_REQD = 100
var $SEMMNS_REQD = 1024
var $SEMMSL_REQD = 256
var $SHMMAX_REQD = 4294967295
var $SHMMNI_REQD = 100

macro chk_min
{var (\@tbl,$nam,$ref,$val) = @arg
 if !defined($val)
 {call push(@tbl,concat($nam,'Undef'))
  return
 }
 if expr('<',$val,$ref)
  call push(@tbl,concat($nam,'TooSmall'))
}

if !loadCommand('/etc/sysdef')
 return setHcveResult('NoAccess')
var $SEMMNI = field('\s+',0,grepLastFile('SEMMNI','f'))
var $SEMMNS = field('\s+',0,grepLastFile('SEMMNS','f'))
var $SEMMSL = field('\s+',0,grepLastFile('SEMMSL','f'))
var $SEMVMX = field('\s+',0,grepLastFile('SEMVMX','f'))
var $SHMMAX = field('\s+',0,grepLastFile('SHMMAX','f'))
var $SHMMNI = field('\s+',0,grepLastFile('SHMMNI','f'))
call chk_min(\@tbl,'SEMMNI',$SEMMNI_REQD,$SEMMNI)
call chk_min(\@tbl,'SEMMNS',$SEMMNS_REQD,$SEMMNS)
call chk_min(\@tbl,'SEMMSL',$SEMMSL_REQD,$SEMMSL)
call chk_min(\@tbl,'SHMMAX',$SHMMAX_REQD,$SHMMAX)
call chk_min(\@tbl,'SHMMNI',$SHMMNI_REQD,$SHMMNI)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel parameters for Solaris 9 x86 are properly set.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK" result="PASSED" syntax="wiki">
<![CDATA[The kernel parameters are set according to the ${'BOOK}. No action required.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki">
<![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. If they have been set in the ``/etc/system`` file, then you may have to add the following to set the parameters at boot time:
``forceload: sys/semsys``
``forceload: sys/shmsys``
When you make the changes in the ``/etc/system`` file, save the file and reboot to take effect.
|*Return Value*|*Action*|
|SEMMNITooSmall|Increase the kernel parameter SEMMNI to 100.|
|SEMMNIUndef|SEMMNI is not defined and must be set to 100.|
|SEMMNSTooSmall|Increase the kernel parameter SEMMNS to at least 1024.|
|SEMMNSUndef|SEMMNS is not defined and must be set to 1024.|
|SEMMSLTooSmall|Increase the kernel parameter SEMMSL to at least 256.|
|SEMMSLUndef|SEMMSL is not defined and must be set to 256.|
|SHMMAXTooSmall|Increase the kernel parameter SHMMAX to 4294967295.|
|SHMMAXUndef|SHMMAX is not defined and must be set to 4294967295.|
|SHMMNITooSmall|Increase the kernel parameter SHMMNI to at least 100.|
|SHMMNIUndef|SHMMNI is not defined and must be set to 100 or more.|
|NoAccess|You do not have access to ``/etc/sysdef``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01010" mode="VERIFY" name="Solaris 10 x86 Params OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Intel SunOS 2.10" result="SKIPPED" value="Not on Solaris 10 x86"><![CDATA[This rule applies to Solaris 10 x86 only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()

macro chk_min
{var (\@tbl,$nam,$ref,$val) = @arg
 if !defined($val)
 {call push(@tbl,concat($nam,'Undef'))
  return
 }
 if expr('<',$val,$ref)
  call push(@tbl,concat($nam,'TooSmall'))
}

macro chk_param
{var ($cmd,$prj) = @arg
 var ($lin) = grepCommand(concat($cmd,' -n ',$prj,' ',${RDA.PID}),\
                          '(basic|privileged|system)','if')
 if match($lin,'\b(\d+(\.\d*)?)(\w*)\b')
  var ($siz,undef,$typ) = (last)
 return check(uc($typ),'^KB?$',expr('*',$siz,1024),\
                       '^MB?$',expr('*',$siz,1048576),\
                       '^GB?$',expr('*',$siz,1073741824),\
                       '^TB?$',expr('*',$siz,1099511627776),\
                       '^PB?$',expr('*',$siz,1125899906842624),\
                       '^EB?$',expr('*',$siz,1152921504606846976),\
                               $siz)
}
var $cmd = findCommand('prctl')
if !defined($cmd)
 return setHcveResult('NoAccess')
call chk_min(\@tbl,'SEMMNI',$SEMMNI_REQD,\
                            chk_param($cmd,'project.max-sem-ids'))
call chk_min(\@tbl,'SEMMSL',$SEMMSL_REQD,\
                            chk_param($cmd,'process.max-sem-nsems'))
call chk_min(\@tbl,'SHMMAX',$SHMMAX_REQD,\
                            chk_param($cmd,'project.max-shm-memory'))
call chk_min(\@tbl,'SHMMNI',$SHMMNI_REQD,\
                             chk_param($cmd,'project.max-shm-ids'))
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel parameters for Solaris 10 x86 are set properly.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK" result="PASSED" syntax="wiki">
<![CDATA[The kernel parameters are set according to the ${'BOOK}. No action required.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki">
<![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. If they have been set in the ``/etc/system`` file, then you may have to add the following to set the parameters at boot time:
``forceload: sys/semsys``
``forceload: sys/shmsys``
When you make the changes in the ``/etc/system`` file, save the file and reboot to take effect.
In Solaris 10, you are not required to make changes to the ``/etc/system`` file to implement the System V IPC. Solaris 10 uses the resource control facility for its implementation.
|*Return Value*|*Action*|
|SEMMNITooSmall|Increase the kernel parameter SEMMNI to 100.|
|SEMMNIUndef|SEMMNI is not defined and must be set to 100.|
|SEMMNSTooSmall|Increase the kernel parameter SEMMNS to at least 1024.|
|SEMMNSUndef|SEMMNS is not defined and must be set to 1024.|
|SEMMSLTooSmall|Increase the kernel parameter SEMMSL to at least 256.|
|SEMMSLUndef|SEMMSL is not defined and must be set to 256.|
|SHMMAXTooSmall|Increase the kernel parameter SHMMAX to 4294967295.|
|SHMMAXUndef|SHMMAX is not defined and must be set to 4294967295.|
|SHMMNITooSmall|Increase the kernel parameter SHMMNI to at least 100.|
|SHMMNIUndef|SHMMNI is not defined and must be set to 100 or more.|
|NoAccess|You do not have access to ``prctl`` command.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01020" mode="VERIFY" name="Solaris 8 SPARC Params OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.8" result="SKIPPED" value="Not on Solaris 8 SPARC"><![CDATA[This rule applies to Solaris 8 SPARC only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
var $NOEXEC_USER_STACK_REQD = 1
var $SEMMNI_REQD = 100
var $SEMMNS_REQD = 256
var $SEMMSL_REQD = 256
var $SHMMAX_REQD = 4294967295
var $SHMMIN_REQD = 1
var $SHMMNI_REQD = 100
var $SHMSEG_REQD = 10

macro chk_min
{var (\@tbl,$nam,$ref,$val) = @arg
 if !defined($val)
 {call push(@tbl,concat($nam,'Undef'))
  return
 }
 if expr('<',$val,$ref)
  call push(@tbl,concat($nam,'TooSmall'))
}

if !loadCommand('/etc/sysdef')
  return setHcveResult('NoAccess')
var $SEMMNI = field('\s+',0,grepLastFile('SEMMNI','f'))
var $SEMMNS = field('\s+',0,grepLastFile('SEMMNS','f'))
var $SEMMSL = field('\s+',0,grepLastFile('SEMMSL','f'))
var $SHMMAX = field('\s+',0,grepLastFile('SHMMAX','f'))
var $SHMMIN = field('\s+',0,grepLastFile('SHMMIN','f'))
var $SHMMNI = field('\s+',0,grepLastFile('SHMMNI','f'))
var $SHMSEG = field('\s+',0,grepLastFile('SHMSEG','f'))

call chk_min(\@tbl,'SEMMNI',$SEMMNI_REQD,$SEMMNI)
call chk_min(\@tbl,'SEMMNS',$SEMMNS_REQD,$SEMMNS)
call chk_min(\@tbl,'SEMMSL',$SEMMSL_REQD,$SEMMSL)
call chk_min(\@tbl,'SHMMAX',$SHMMAX_REQD,$SHMMAX)
call chk_min(\@tbl,'SHMMIN',$SHMMIN_REQD,$SHMMIN)
call chk_min(\@tbl,'SHMMNI',$SHMMNI_REQD,$SHMMNI)
call chk_min(\@tbl,'SHMSEG',$SHMSEG_REQD,$SHMSEG)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel parameters for Solaris 8 SPARC are set properly.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK|Not Required" result="PASSED">
<![CDATA[No action required.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. If they have been set in the ``/etc/system`` file, then you may have to add the following to set the parameters at boot time:
``forceload: sys/semsys``
``forceload: sys/shmsys``
When you make the changes in the ``/etc/system`` file, save the file and reboot to take effect.
|*Return Value*|*Action*|
|NOEXEC_USER_STACKTooSmall|Increase the kernel parameter NOEXEC_USER_STACK to 1.|
|NOEXEC_USER_STACKUndef|NOEXEC_USER_STACK is not defined and must be set to 1.|
|SEMMNITooSmall|Increase the kernel parameter SEMMNI to 100.|
|SEMMNIUndef|SEMMNI is not defined and must be set to 100.|
|SEMMNSTooSmall|Increase the kernel parameter SEMMNS to at least 1024.|
|SEMMNSUndef|SEMMNS is not defined and must be set to 1024.|
|SEMMSLTooSmall|Increase the kernel parameter SEMMSL to at least 256.|
|SEMMSLUndef|SEMMSL is not defined and must be set to 256.|
|SHMMAXTooSmall|Increase the kernel parameter SHMMAX to 4294967295.|
|SHMMAXUndef|SHMMAX is not defined and must be set to 4294967295.|
|SHMMINTooSmall|Increase the kernel parameter SHMMIN to at least 1.|
|SHMMINUndef|SHMMIN is not defined and must be set to 1 or more.|
|SHMMNITooSmall|Increase the kernel parameter SHMMNI to at least 100.|
|SHMMNIUndef|SHMMNI is not defined and must be set to 100 or more.|
|SHMSEGTooSmall|Increase the kernel parameter SHMSEG to at least 10.|
|SHMSEGUndef|SHMSEG is not defined and must be set to 10 or more.|
|NoAccess|You do not have access to ``/etc/sysdef``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01030" mode="VERIFY" name="Solaris 9 SPARC Params OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.9" result="SKIPPED" value="Not on Solaris 9 SPARC"><![CDATA[This rule applies to Solaris 9 SPARC only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()
var $NOEXEC_USER_STACK_REQD = 1
var $SEMMNI_REQD = 100
var $SEMMNS_REQD = 256
var $SEMMSL_REQD = 256
var $SHMMAX_REQD = 4294967295
var $SHMMNI_REQD = 100

macro chk_min
{var (\@tbl,$nam,$ref,$val) = @arg
 if !defined($val)
 {call push(@tbl,concat($nam,'Undef'))
  return
 }
 if expr('<',$val,$ref)
  call push(@tbl,concat($nam,'TooSmall'))
}

if !loadCommand('/etc/sysdef')
  return setHcveResult('NoAccess')
var $SEMMNI = field('\s+',0,grepLastFile('SEMMNI','f'))
var $SEMMNS = field('\s+',0,grepLastFile('SEMMNS','f'))
var $SEMMSL = field('\s+',0,grepLastFile('SEMMSL','f'))
var $SHMMAX = field('\s+',0,grepLastFile('SHMMAX','f'))
var $SHMMNI = field('\s+',0,grepLastFile('SHMMNI','f'))

call chk_min(\@tbl,'SEMMNI',$SEMMNI_REQD,$SEMMNI)
call chk_min(\@tbl,'SEMMNS',$SEMMNS_REQD,$SEMMNS)
call chk_min(\@tbl,'SEMMSL',$SEMMSL_REQD,$SEMMSL)
call chk_min(\@tbl,'SHMMAX',$SHMMAX_REQD,$SHMMAX)
call chk_min(\@tbl,'SHMMNI',$SHMMNI_REQD,$SHMMNI)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel parameters for Solaris 9 SPARC are set properly.]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK|Not Required" result="PASSED">
<![CDATA[No action required.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. If they have been set in the ``/etc/system`` file, then you may have to add the following to set the parameters at boot time:
``forceload: sys/semsys``
``forceload: sys/shmsys``
When you make the changes in the ``/etc/system`` file, save the file and reboot to take effect.
|*Return Value*|*Action*|
|NOEXEC_USER_STACKTooSmall|Increase the kernel parameter NOEXEC_USER_STACK to 1.|
|NOEXEC_USER_STACKUndef|NOEXEC_USER_STACK is not defined and must be set to 1.|
|SEMMNITooSmall|Increase the kernel parameter SEMMNI to 100.|
|SEMMNIUndef|SEMMNI is not defined and must be set to 100.|
|SEMMNSTooSmall|Increase the kernel parameter SEMMNS to at least 1024.|
|SEMMNSUndef|SEMMNS is not defined and must be set to 1024.|
|SEMMSLTooSmall|Increase the kernel parameter SEMMSL to at least 256.|
|SEMMSLUndef|SEMMSL is not defined and must be set to 256.|
|SHMMAXTooSmall|Increase the kernel parameter SHMMAX to 4294967295.|
|SHMMAXUndef|SHMMAX is not defined and must be set to 4294967295.|
|SHMMNITooSmall|Increase the kernel parameter SHMMNI to at least 100.|
|SHMMNIUndef|SHMMNI is not defined and must be set to 100 or more.|
|NoAccess|You do not have access to ``/etc/sysdef``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01040" mode="VERIFY" name="Solaris 10 SPARC Params OK?">
<sdp_dependencies>
<sdp_dependency condition="=~" id="A00010" minimum="^Sparc SunOS 2.10" result="SKIPPED" value="Not on Solaris 10 SPARC"><![CDATA[This rule applies to Solaris 10 SPARC only.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var @tbl = ()

macro chk_min
{var (\@tbl,$nam,$ref,$val) = @arg
 if !defined($val)
 {call push(@tbl,concat($nam,'Undef'))
  return
 }
 if expr('<',$val,$ref)
  call push(@tbl,concat($nam,'TooSmall'))
}

macro chk_param
{var ($cmd,$prj) = @arg
 var ($lin) = grepCommand(concat($cmd,' -n ',$prj,' ',${RDA.PID}),\
                          '(basic|privileged|system)','if')
 if match($lin,'\b(\d+(\.\d*)?)(\w*)\b')
  var ($siz,undef,$typ) = (last)
 return check(uc($typ),'^KB?$',expr('*',$siz,1024),\
                       '^MB?$',expr('*',$siz,1048576),\
                       '^GB?$',expr('*',$siz,1073741824),\
                       '^TB?$',expr('*',$siz,1099511627776),\
                       '^PB?$',expr('*',$siz,1125899906842624),\
                       '^EB?$',expr('*',$siz,1152921504606846976),\
                               $siz)
}
var $cmd = findCommand('prctl')
call chk_min(\@tbl,'SHMMAX',$SHMMAX_REQD,\
             chk_param($cmd,'project.max-shm-memory'))
call chk_min(\@tbl,'SHMMNI',$SHMMNI_REQD,\
             chk_param($cmd,'project.max-shm-ids'))
call chk_min(\@tbl,'SEMMNI',$SEMMNI_REQD,\
             chk_param($cmd,'project.max-sem-ids'))
call chk_min(\@tbl,'SEMMSL',$SEMMSL_REQD,\
             chk_param($cmd,'process.max-sem-nsems'))
call chk_min(\@tbl,'NOEXEC_USER_STACK',$NOEXEC_USER_STACK_REQD,\
             $NOEXEC_USER_STACK)
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'KernelOK'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule verifies that the kernel parameters for Solaris 10 SPARC are set properly.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="KernelOK" result="PASSED"><![CDATA[No action required.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The kernel parameters are not set according to the ${'BOOK}. For the recommended values, see the ${'BOOK}. If they have been set in the ``/etc/system`` file, then you may have to add the following to set the parameters at boot time:
forceload: sys/semsys
forceload: sys/shmsys
When you make the changes in the ``/etc/system`` file, save the file and reboot to take effect.
|*Return Value*|*Action*|
|NOEXEC_USER_STACKTooSmall|Increase the kernel parameter NOEXEC_USER_STACK to 1.|
|NOEXEC_USER_STACKUndef|NOEXEC_USER_STACK is not defined and must be set to 1.|
|SEMMNITooSmall|Increase the kernel parameter SEMMNI to 100.|
|SEMMNIUndef|SEMMNI is not defined and must be set to 100.|
|SEMMNSTooSmall|Increase the kernel parameter SEMMNS to at least 1024.|
|SEMMNSUndef|SEMMNS is not defined and must be set to 1024.|
|SEMMSLTooSmall|Increase the kernel parameter SEMMSL to at least 256.|
|SEMMSLUndef|SEMMSL is not defined and must be set to 256.|
|SHMMAXTooSmall|Increase the kernel parameter SHMMAX to 4294967295.|
|SHMMAXUndef|SHMMAX is not defined and must be set to 4294967295.|
|SHMMINTooSmall|Increase the kernel parameter SHMMIN to at least 1.|
|SHMMINUndef|SHMMIN is not defined and must be set to 1 or more. |
|SHMMNITooSmall|Increase the kernel parameter SHMMNI to at least 100.|
|SHMMNIUndef|SHMMNI is not defined and must be set to 100 or more.|
|SHMSEGTooSmall|Increase the kernel parameter SHMSEG to at least 10.|
|SHMSEGUndef|SHMSEG is not defined and must be set to 10 or more.|
|NoAccess|You do not have access to ``/etc/sysdef``.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01100" mode="RECORD" name="Host Domain Name">
<sdp_command type="RDA"><![CDATA[var ($hst) = command('hostname')
var ($nam,$dom) = split('\.',$hst,2)
if testFile('x','/bin/domainname')
 var ($nis) = command('/bin/domainname')
if testFile('r','/etc/resolv.conf')
 var $dns = field('\s+',1,grepFile('/etc/resolv.conf','domain'))
if testFile('x','/usr/sbin/nslookup')
{if $nam
 {var $nsl = field(concat(quote($nam),'\.'),1,\
                   grepCommand(concat('/usr/sbin/nslookup ',$hst),'Name','f'))
 }
 else
 {var $nsl = field(concat(quote($hst),'\.'),1,\
                   grepCommand(concat('/usr/sbin/nslookup ',$hst),'Name','f'))
 }
}
call setHcveResult(cond($dom,$dom,\
                        $nis,$nis,\
                        $dns,$dns,\
                        $nsl,$nsl,\
                             'NotFound'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule gets the host domain name.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A01110" mode="RECORD" name="IP Address">
<sdp_command type="RDA"><![CDATA[var ($hst) = command('hostname')
var $ip = field('\s+',1,grepCommand(concat('/usr/sbin/ping -a ',$hst),'.','f'))
call setHcveResult(substr($ip,1,expr('-',length($ip),2)))]]>
</sdp_command>
<sdp_description><![CDATA[This rule gets the host IP address.]]></sdp_description>
</sdp_rule>

<sdp_rule id="A01120" mode="VERIFY" name="Format /etc/hosts OK?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A01100" minimum="RECORD" result="SKIPPED"><![CDATA[This rule needs domain name.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
if !testFile('r','/etc/hosts')
 return setHcveResult('Cannot access /etc/hosts')
if !@tbl = grepFile('/etc/hosts',\
  concat('^([^\s\#]+\s+)+',quote(${RDA.HOST}),\
         '\s+([^\s\#]+\s+)*',quote(${RDA.NODE}),'(\s|\z|\#)'))
 return setHcveResult('no entry found')

# Test that line begins with IPv4 IP address
if grep(@tbl,'^(\d{1,3}\.){3}\d{1,3}\s','f')
 return setHcveResult('Adequate IPv4 entry')

# Tests that line begins with IPv6 IP address, first that all eight groups are populated, then situations where groups that are all zero are omitted (two colons together).
if grep(@tbl,'^([A-F\d]{1,4}(:[A-F\d]{1,4}){7}\s|\
                :(:[A-F\d]{1,4}){1,6}\s|\
                ([A-F\d]{1,4}:){1,5}(:[A-F\d]{1,4}){1,5}\s|\
                ([A-F\d]{1,4}:){1,6}:\s)','f')
 return setHcveResult('Adequate IPv6 entry')
return setHcveResult('no correct entry found')
]]></sdp_command>
<sdp_description><![CDATA[This rule checks that the ``/etc/hosts`` file contains a line with ``ip_address fully_qualified_domainname short_hostname``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="^Adequate" result="PASSED"><![CDATA[The ``/etc/hosts`` entry for the fully qualified domain name and host name is adequate.]]></sdp_action>
<sdp_action condition="==" minimum="Cannot access /etc/hosts" result="FAILED"><![CDATA[Grant read permissions on ``/etc/hosts`` to the current user.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The fully qualified host name and host name are not configured correctly. Ensure that there is an IP address entry for the fully qualified domain name with the host name as one of the aliases.
|*Return Value*|*Action"|
|no entry found|No entry with the fully qualified domain name followed by the host name was found.|
|no correct entry found|No entry beginning with an IP address with the fully qualified domain name followed by the host name was found.|]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01130" mode="VERIFY" name="DHCP Client Check?">
<sdp_command type="RDA"><![CDATA[call setHcveResult(cond(\
  grepCommand('ps -leaf','dhcpagent','f'),'Possible dhcpagent daemon running',\
                                          'dhcpagent daemon not running'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the server is running DHCP client (dhcpagent daemon). DHCP clients are not supported.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="dhcpagent daemon not running" result="PASSED">
<![CDATA[This server is not using a DHCP client. No action required.]]>
</sdp_action>
<sdp_action result="FAILED">
<![CDATA[DHCP clients are not supported. You must use a static IP address and host name.]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01140" mode="VERIFY" name="DNS Lookup?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="A01110" minimum="RECORD" result="SKIPPED"><![CDATA[This rule needs IP address.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var $ip  = "%A01110%"
var $hst = field('\.',0,command('hostname'))
call setHcveResult(cond(\
  not(length($ip)),\
    'Cannot determine IP address',\
  not(testFile('x','/usr/sbin/nslookup')),\
    'Cannot access /usr/sbin/nslookup',\
  and(grepCommand(concat('/usr/sbin/nslookup ',$hst),quote($ip),'f'),\
      grepCommand(concat('/usr/sbin/nslookup ',$ip),quote($hst),'f')),\
    'Host correctly registered in DNS',\
    'Host not correctly registered in DNS'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the host is registered correctly in the DNS.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Host correctly registered in DNS" result="PASSED">
<![CDATA[The host is registered correctly in the DNS.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Host not correctly registered in DNS|Register the host.domain in the DNS.|
|Cannot determine IP address|Fix any problem with the host IP address.|
|Cannot access /usr/sbin/nslookup|Grant execute permissions on ``/usr/sbin/nslookup`` to the user who is logged in.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01150" mode="VERIFY" name="Host Name Length?">
<sdp_command type="RDA"><![CDATA[var $hst = uname('n')
call setHcveResult(cond(\
  expr('>',length($hst),255),'Host name is greater than 255 characters',\
                             'Host name is less than 255 characters'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that your fully qualified host name is not longer than 255 characters.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Host name is less than 255 characters" result="PASSED">
<![CDATA[The host name is less than 255 characters. No action required.]]>
</sdp_action>
<sdp_action result="FAILED"><![CDATA[Modify your fully qualified host name to less than 255 characters.]]></sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01160" mode="VERIFY" name="Port 1521 Available?">
<sdp_command type="RDA"><![CDATA[var @lst = grepCommand('/bin/netstat -an',\
'LISTEN')
if !grep(@lst,'1521','f')
 return setHcveResult('Free')
if testFile('x','/usr/sbin/lsof')
 var ($prc) = grepCommand('/usr/sbin/lsof -i TCP:1521','LIST','f')
elsif testFile('x','/usr/bin/lsof')
 var ($prc) = grepCommand('/usr/bin/lsof -i TCP:1521','LIST','f')
elsif testFile('x','/usr/local/bin/lsof')
 var ($prc) = grepCommand('/usr/local/bin/lsof -i TCP:1521','LIST','f')
else
 return setHcveResult('Cannot use lsof')
if !length($prc)
 return setHcveResult('Cannot use lsof')
macro chk_tns
{var ($prc) = @arg
 var @cmd = grepCommand('ps -ef',field('\s+',1,$prc))
 var @ver = command(replace(field(\
    '\s+',8,grep(@cmd,'tnslsnr','f')),'tnslsnr','lsnrctl version'))
 var $ver = field('\s+',4,grep(@ver,'LSNRCTL','f'))
 return cond(compare('older',$ver,'10.1.0.2.0'),\
             concat('TNS Listener version [',$ver,'] is running'),\
             'TNS Listener 10.1.0.2 or later is running')
}
call setHcveResult(cond(not(match(field('\s+',0,$prc),'tnslsnr',true)),\
                        'Port is used by non-Oracle program',\
                        chk_tns($prc)))]]>
</sdp_command>
<sdp_description>
<![CDATA[This rule checks that port 1521 is free. If an Oracle listener version 10.1.0.2 or later uses port 1521, then the existing database and the Oracle Application Server 10g Metadata Repository will use the existing listener. The installer performs this configuration automatically. If an Oracle listener version earlier than 10.1.0.2 uses port 1521, then the existing listener must be stopped. After the installation is complete, you can configure the new 10.1.0.2 listener to listen to the existing (pre 10.1.0.2) databases. If non-Oracle programs use port 1521, then this program must be configured to listen to ports other than 1521. For more information, see the ''If Port 1521 is in Use'' section of the installation guide.]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="TNS Listener 10.1.0.2 or later is running|Free" result="PASSED">
<![CDATA[Port 1521 is not used or is used by TNS Listener version 10.1.0.2 or later.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|TNS Listener version ... is running|Stop the existing listener.|
|Port is used by non-Oracle program|Reconfigure the program to use a different port to 1521.|
|Cannot use lsof|Check port 1521 manually.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01170" mode="VERIFY" name="Oracle Home Length?">
<sdp_command type="RDA"><![CDATA[var $ORACLE_HOME = getEnv('ORACLE_HOME')
call setHcveResult(cond(\
  not(defined($ORACLE_HOME)),\
    'ORACLE_HOME is not set',\
  expr('<=',length($ORACLE_HOME),127),\
    'Less than 127 char',\
    'Longer than 127 characters'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the path to the Oracle home directory is not longer than 127 characters.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Less than 127 char" result="PASSED">
<![CDATA[The Oracle home directory is not longer than 127 characters.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Longer than 127 characters|Change ORACLE_HOME to a directory not longer than 127 characters.|
|ORACLE_HOME is not set|Set the ORACLE_HOME environment variable.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01210" mode="VERIFY" name="NLS_LANG Defined?">
<sdp_command type="RDA"><![CDATA[var $env = getEnv('NLS_LANG')
call setHcveResult(cond(\
  not(defined($env)),\
    'Not set',\
  match($env,'american_america',true),\
    'Set properly',\
    'Not set properly'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the ``NLS_LANG`` environment variable is defined. If it is defined, then it must be set to American_America, otherwise the Oracle Internet Directory (OID) Configuration Assistant will fail.]]>
</sdp_description>
<sdp_actions>
<sdp_action condition="=~" minimum="Not set|Set properly" result="PASSED">
<![CDATA[The ``NLS_LANG`` environment variable is set properly or else is not set.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Not set properly|Set the ``NLS_LANG`` environment variable to ``AMERICAN_AMERICA.&lt;characterset&gt;``|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01220" mode="VERIFY" name="Monitor Colors?">
<sdp_command type="RDA"><![CDATA[call loadCommand(\
'/usr/X11R6/bin/xdpyinfo -root 2>&1')
var @dpt = grepLastFile('depth')
call setHcveResult(cond(\
  grep(@dpt,'8','f'),             'Adequate',\
  not(defined(getEnv('DISPLAY'))),'DISPLAY is not set',\
  grepLastFile('unable','f'),     'Cannot open DISPLAY',\
                                  'Need at least 256 colors'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the monitor has a minimum of 256 colors. Several components or X-Windows programs could require it unless you have already deployed workarounds for each of them.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Adequate" result="PASSED">
<![CDATA[The monitor has enough colors.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Need at least 256 colors|Use a display with at least 256 colors.|
|DISPLAY is not set|Set the DISPLAY environment variable to a valid display.|
|Cannot open DISPLAY|Set the DISPLAY environment variable to a correct display.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

<sdp_rule id="A01230" mode="VERIFY" name="Application Bit Support OK?">
<sdp_command type="RDA"><![CDATA[import $OS_ARC
var $pth = findCommand('isainfo')
if !$pth
 return setHcveResult('Cannot access isainfo command')
if match($OS_ARC,'Sparc')
{call loadCommand(concat($pth,' -v'))
 call setHcveResult(cond(\
   and(grepLastFile('64\-bit','f'),grepLastFile('32\-bit','f')),\
     'BitSupportOK',\
     'Need32And64Bit'))
}
else
 call setHcveResult(cond(grepCommand(concat($pth,' -v'),'32\-bit','f'),\
                         'BitSupportOK','No32BitSupport'))]]>
</sdp_command>
<sdp_description><![CDATA[This rule checks that the operating system is configured to support 32-bit applications for an Intel processor or to support 32-bit and 64-bit applications for a SPARC processor.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="BitSupportOK" result="PASSED">
<![CDATA[No action required. The system supports all required applications.]]>
</sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[|*Return Value*|*Action*|
|Cannot access isainfo command|Make sure that the ``isainfo`` executable is accessible to the user who is logged in.|
|No32BitSupport|Configure the system to support 32-bit applications.|
|Need32And64Bit|Configure the system to support both 32-bit and 64-bit applications.|]]>
</sdp_action>
</sdp_actions>
</sdp_rule>

</sdp_group>
</sdp_content>
</sdp_diaglet>
