<sdp_diaglet platform="linux" product="RAC" set="P400RAC_lnx" title="RAC 10G DB and OS Best Practices (Linux)" type="P">
<sdp_meta id="$Id: P400RAC_lnx.xml,v 2.3 2010/11/23 13:11:58 mschenke Exp $" type="version"/>
<sdp_meta author="LDE" change="Improve Documentation" date="20101123" type="history"/>
<sdp_content set="P400RAC_lnx" title="RAC 10G DB and OS Best Practices (Linux)" type="check">
<sdp_group>
<sdp_rule id="P00010" mode="RECORD" name="ORA_CRS_HOME">
<sdp_command type="RDA"><![CDATA[call initRemote()
var $ORA_CRS_HOME = getEnv('ORA_CRS_HOME')
if !testDir('d',$ORA_CRS_HOME)
{if grepFile('/etc/init.d/init.cssd','^ORA_CRS_HOME=','f')
  var $ORA_CRS_HOME = value(last)
}
call setHcveResult($ORA_CRS_HOME)
]]></sdp_command>
<sdp_description><![CDATA[This rule records the value of ORA_CRS_HOME.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00100" mode="RECORD" name="Database Name">
<sdp_command type="RDA"><![CDATA[set $sql
{SELECT 'VERSION=' || version
" FROM v$instance;
"SELECT name || '=' || value 
" FROM v$parameter
" WHERE name IN ('cpu_count',
"                'db_block_size',
"                'db_file_multiblock_read_count',
"                'db_name',
"                'max_commit_propagation_delay',
"                'parallel_execution_message_size',
"                'parallel_min_servers');
"SELECT sequence_name || '=' || cache_size
" FROM dba_sequences
" WHERE sequence_name IN ('AUDSES$','IDGEN1$')
"   AND sequence_owner = 'SYS';
"SELECT 'INTERCONNECT_NETWORK=' || SUBSTR(ip_ksxpia,1,7)
" FROM x$ksxpia;
}
call loadSql($sql)
call setHcveResult(value(grepLastSql('db_name=','f')))
]]></sdp_command>
<sdp_description><![CDATA[This rule loads database parameters and records the database name.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00102" mode="RECORD" name="Database Version">
<sdp_command type="RDA"><![CDATA[call setHcveResult(value(grepLastSql('VERSION=','f')))
]]></sdp_command>
<sdp_description><![CDATA[This rule records the database version.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00104" mode="RECORD" name="Interconnect Network">
<sdp_command type="RDA"><![CDATA[call setHcveResult(\
value(grepLastSql('INTERCONNECT_NETWORK=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule records the value of the Interconnect Network.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00106" mode="RECORD" name="DB Block Size">
<sdp_command type="RDA"><![CDATA[call setHcveResult(\
value(grepLastSql('db_block_size=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule records the db_block_size database parameter.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00108" mode="RECORD" name="DB File Multiblock Read Count">
<sdp_command type="RDA"><![CDATA[call setHcveResult(\
value(grepLastSql('db_file_multiblock_read_count','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule records the db_file_multiblock_read_count database parameter.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00120" mode="VERIFY" name="Max Commit Propagation Delay">
<sdp_command type="RDA"><![CDATA[call setHcveResult(\
value(grepLastSql('max_commit_propagation_delay=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the max_commit_propagation_delay database parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="0" result="PASSED" syntax="wiki"><![CDATA[The value of the max_commit_propagation_delay database parameter is set to zero.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The value of the max_commit_propagation_delay database parameter is not set to zero. Set the value to zero.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00130" mode="VERIFY" name="SYS.AUDSES$ Cache Size">
<sdp_command type="RDA"><![CDATA[call setHcveResult(value(grepLastSql('AUDSES\$=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the cache_size parameter for sequence SYS.AUDSES$.]]></sdp_description>
<sdp_actions>
<sdp_action condition=">=" minimum="10000" result="PASSED" syntax="wiki"><![CDATA[The cache size for sequence SYS.AUDSES$ is greater than or equal to 10,000.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The cache size for sequence SYS.AUDSES$ is less than 10,000. Set the cache size greater than or equal to 10,000.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00132" mode="VERIFY" name="SYS.IDGEN1$ Cache Size">
<sdp_command type="RDA"><![CDATA[call setHcveResult(value(grepLastSql('IDGEN1\$=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the cache_size parameter for sequence SYS.IDGEN1$.]]></sdp_description>
<sdp_actions>
<sdp_action condition=">=" minimum="10000" result="PASSED" syntax="wiki"><![CDATA[The cache size for sequence SYS.IDGEN1$ is greater than or equal to 10,000.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The cache size for sequence SYS.IDGEN1$ is less than 10,000. Set the cache size greater than or equal to 10,000.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00140" mode="VERIFY" name="Parallel Execution Msg Size">
<sdp_command type="RDA"><![CDATA[call setHcveResult(value(grepLastSql('parallel_execution_message_size=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the parallel_execution_message_size database parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition=">=" minimum="4096" result="PASSED" syntax="wiki"><![CDATA[The value of the parallel_execution_message_size database parameter is greater than or equal to 4096.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The value of the parallel_execution_message_size database parameter is less than 4096. Set the value to 4096 or 8192.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00150" mode="RECORD" name="Min Parallel Servers">
<sdp_command type="RDA"><![CDATA[call setHcveResult(expr('-',value(grepLastSql('cpu_count=','f')),1))]]></sdp_command>
<sdp_description><![CDATA[This rule records the minimum number of parallel servers.]]></sdp_description>
</sdp_rule>
<sdp_rule id="P00152" mode="VERIFY" name="parallel_min_servers">
<sdp_command type="RDA"><![CDATA[call setHcveResult(value(grepLastSql('parallel_min_servers=','f')))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the parallel_min_servers database parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition=">=" minimum="%P00150%" result="PASSED" syntax="wiki"><![CDATA[The value of the parallel_min_servers database parameter is greater than or equal to %P00150%.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The value of the parallel_min_servers database parameter is less than %P00150%. Set the value to greater than or equal to %P00150%.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00200" mode="VERIFY" name="$ORA_CRS_HOME Defined?">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00010" minimum="RECORD" result="FAILED"><![CDATA[Requires rule A00010.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[call setHcveResult(cond(testDir('d',"%P00010%"),'Found','Missing'))]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the existence of $ORA_CRS_HOME directory.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Found" result="PASSED" syntax="wiki"><![CDATA[The $ORA_CRS_HOME directory exists.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The $ORA_CRS_HOME directory does not exist or is not set correctly. Set the value of the ORA_CRS_HOME environment variable.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00210" mode="VERIFY" name="RemoteNodeInfo">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00010" minimum="RECORD" result="FAILED"><![CDATA[Requires rule A00010.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[var ($ORA_CRS_HOME,@tbl) = ("%P00010%")
macro get_remote
{var (\@tbl,$id,$nod,$ora,$crs) = @arg
 
 var %tbl = ()
 if rexec($id,"uname -a",true)
  call push(@tbl,$nod)
 else
 {var ($sys{$nod}) = getRemoteLines()
  var $tbl{'uname'} = $sys{$nod}

  if !rexec($id,'env',true)
  {loop $lin (getRemoteLines())
   {var $key = key($lin)
    if compare('eq',$key,'ORACLE_HOME')
    {if !$ora
      var $ora = value($lin)
     break $crs
    }
    elsif match($key,'^(ORA_)CRS_HOME$')
    {if !$crs
      var $crs = value($lin)
     break $ora
    }
   }
  }

  if !$crs
   var $crs = "%P00010%"
  if $crs
  {if !rexec($id,concat('grep "_USR_ORA_DEBUG=" ',\
                        catCommand($crs,'bin','racgwrap')),true)
   {var $tbl{'dbg_crs'} = '?'
    loop $lin (getRemoteLines())
    {var $lin =  replace($lin,'#.*$')
     if compare('eq',key($lin),'_USR_ORA_DEBUG')
      var $tbl{'dbg_crs'} = value($lin)
    }
   }
  }

  if !$ora
   var $ora = getEnv('ORACLE_HOME')
  if $ora
  {if !rexec($id,concat('grep "_USR_ORA_DEBUG=" ',\
                        catFile($ora,'bin','racgwrap')),true)
   {var $tbl{'dbg_ora'} = '?'
    loop $lin (getRemoteLines())
    {var $lin =  replace($lin,'#.*$')
     if compare('eq',key($lin),'_USR_ORA_DEBUG')
      var $tbl{'dbg_ora'} = value($lin)
    }
   }

   if !rexec($id,concat('nm ',catCommand($ora,'bin','oracle'),\
                        ' | grep io_getevents'),true)
    var $tbl{'lib_aio'} = nvl(field('\s+',1,getRemoteLines()),'')

   var $inv = catCommand($ora,'inventory','ContentsXML','comps.xml')
   var $ref = '0.0.0.0.0'
   if !rexec($id,concat('grep "\[PT\]\ NAME=.oracle\.server" ',$inv),true)
   {loop $lin (getRemoteLines())
    {var (undef,$ver) = match($lin,'<(COMP|PATCHSET)\s.*?\sVER="([\d\.]+)"')
     if compare('newer',$ver,$ref)
      var $ref = $ver
    }
   }
   var $ref = replace($ref,'\.\d+$')
   var $tbl{'patchset'} = $ref

   if compare('eq',$ref,'10.1.0.5')
    var @lst = (4496339,4518443,4528572,5090822,5406923,5496454,5501362)
   elsif compare('eq',$ref,'10.1.0.4')
    var @lst = (4215207,4463426,4518443,4539420,4694761,4902267,5021063)
   else
    var @lst = ()
   loop $num (@lst)
   {if rexec($id,concat('grep -sq "Oneoffs21\/',$num,'" ',$inv))
     var $tbl{'patch'} = join(',',$tbl{'patch'},$num)
   }
   if missing($tbl{'patch'})
    var $tbl{'patch'} = ''
  }

  if !rexec($id,"getconf LONG_BIT",true)
   var ($tbl{'bit'}) = getRemoteLines()
  if !rexec($id,"cat /proc/sys/fs/aio-max-size",true)
   var ($tbl{'aio_max'}) = getRemoteLines()
  if !rexec($id,"cat /proc/sys/kernel/sysrq",true)
   var ($tbl{'sys_req'}) = getRemoteLines()
  if !rexec($id,"free",true)
  {var @tmp = getRemoteLines()
   var $tbl{'mem'} = field('\s+',1,grep(@tmp,'^Mem:','f'))
   var $tbl{'swp'} = field('\s+',1,grep(@tmp,'^Swap:','f'))
  }
  if !rexec($id,"cat /proc/sys/net/core/rmem_max",true)
   var ($tbl{'rmm_max'}) = getRemoteLines()
  if !rexec($id,"cat /proc/sys/net/core/wmem_max",true)
   var ($tbl{'wmm_max'}) = getRemoteLines()
  if !rexec($id,"cat /proc/sys/net/core/rmem_default",true)
   var ($tbl{'rmm_def'}) = getRemoteLines()
  if !rexec($id,"cat /proc/sys/net/core/wmem_default",true)
   var ($tbl{'wmm_def'}) = getRemoteLines()
  if !rexec($id,"/sbin/lsmod |grep 'hangcheck-timer'",true)
   var $tbl{'hng_chk'} = field('\s+',0,getRemoteLines())
 }
 call setDataValue($nod,{%tbl})
}

if getSetting('REMOTE_NODES')
{loop $id (split(',',last))
 {var ($nod,$ora) = getSetting(concat('REMOTE_',$id,'_HOSTNAME'))
  var @nod = (@nod,$nod)
  if getRemoteSetup($id,true)
  {var $cfg = getGroupFile('D_CWD',last)
   loop $lin (grepFile($cfg,'^ORACLE_HOME='))
    var $ora = value($lin)
  }
  call get_remote(\@tbl,$id,$nod,$ora)
 }
}
else
{if command(catCommand($ORA_CRS_HOME,'bin','olsnodes'))
  var @nod = last
 else
  var @nod = command(catCommand($ORA_CRS_HOME,'bin','lsnodes'))
 else
  var @nod = ()
 loop $nod (@nod)
 {call setTempSetting('REMOTE_RAC_DESCRIPTION',concat('Cluster node ',$nod))
  call setTempSetting('REMOTE_RAC_HOSTNAME',$nod)
  call get_remote(\@tbl,'RAC',$nod)
 }
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),\
                   cond(scalar(@nod),'All loaded','None')))
]]></sdp_command>
<sdp_description><![CDATA[This rule collects the remote node information.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All loaded" result="PASSED" syntax="wiki"><![CDATA[The remote node information is loaded successfully.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The reported nodes are not reachable. Take the appropriate actions.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00220" mode="VERIFY" name="_USR_ORA_DEBUG / CRS">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'dbg_crs')
 next compare('eq',$val,'1')
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'All Set'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies that ``_USR_ORA_DEBUG`` is set to ``1`` in ``$ORA_CRS_HOME/bin/racgwrap``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All Set" result="PASSED" syntax="wiki"><![CDATA[The _USR_ORA_DEBUG parameter is set to 1 in ``$ORA_CRS_HOME/bin/racgwrap``.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the _USR_ORA_DEBUG parameter is missing or it is not set to 1 in some nodes. Set the _USR_ORA_DEBUG parameter to 1 in ``$ORA_CRS_HOME/bin/racgwrap`` for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00230" mode="VERIFY" name="_USR_ORA_DEBUG / ORA">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import %dbg_ora
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'dbg_ora')
 next compare('eq',$val,'1')
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'All Set'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies that _USR_ORA_DEBUG is set to 1 in ``$ORACLE_HOME/bin/racgwrap``.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="All Set" result="PASSED" syntax="wiki"><![CDATA[The _USR_ORA_DEBUG parameter is set to 1 in ``$ORACLE_HOME/bin/racgwrap``.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the _USR_ORA_DEBUG parameter is missing or it is not set to 1 in some nodes. Set the _USR_ORA_DEBUG parameter to 1 in ``$ORACLE_HOME/bin/racgwrap`` for the failed nodes.
When the status is 'Unknown', check the connectivity to the node first and then check that the ORACLE_HOME variable is set.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00240" mode="VERIFY" name="rmem_max">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import %rmm_max
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'rmm_max')
 next expr('>=',$val,262144)
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the value of the rmem_max User Datagram Protocol parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The ``/proc/sys/net/core/rmem_max`` parameter is greater than or equal to 262,144.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the rmem_max parameter is missing or it is less than 262,144 in some nodes. Set the value in ``/proc/sys/net/core/rmem_max`` to greater than or equal to 262,144 for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00250" mode="VERIFY" name="UDP Buffer Size">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00106" minimum="RECORD" result="FAILED"><![CDATA[Requires rule A00106.]]></sdp_dependency>
<sdp_dependency condition="IS" id="P00108" minimum="RECORD" result="FAILED"><![CDATA[Requires rule A00108.]]></sdp_dependency>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
var $BUF_REQD = expr('*',num('%P00108%',0),num('%P00106%',0))
call setHcveVariable('$BUF_REQD')
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'rmm_max')
 if !defined($val)
  call push(@tbl,concat($nod,':Unknown'))
 next or(expr('<=',$BUF_REQD,262144),expr('>=',$val,$BUF_REQD))
 call push(@tbl,concat($nod,':',$val))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the value of the User Datagram Protocol Buffer Size parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The User Datagram Protocol buffer size is less than ${BUF_REQD}.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[In some nodes, the User Datagram Protocol buffer size is lower than the product of db_file_multiblock_read_count and db_block_size. Set the value of rmem_max to ${BUF_REQD} or higher.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00260" mode="VERIFY" name="wmem_max">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'wmm_max')
 next expr('>=',$val,262144)
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the value of the wmem_max User Datagram Protocol parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The ``/proc/sys/net/core/wmem_max`` parameter is greater than or equal to 262,144.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the wmem_max parameter is missing or it is less than 262,144 in some nodes. Set the value in ``/proc/sys/net/core/wmem_max`` to greater than or equal to 262,144 for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00270" mode="VERIFY" name="rmem_default">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'rmm_def')
 next expr('>=',$val,262144)
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the value of the rmem_default User Datagram Protocol parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The ``/proc/sys/net/core/rmem_default`` parameter is greater than or equal to 262,144.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the rmem_default parameter is missing or it is less than 262,144 in some nodes. Set the value in ``/proc/sys/net/core/rmem_default`` to greater than or equal to 262,144 for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00280" mode="VERIFY" name="wmem_default">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'wmm_def')
 next expr('>=',$val,262144)
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the value of the wmem_default User Datagram Protocol parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The ``/proc/sys/net/core/wmem_default`` parameter is greater than or equal to 262,144.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the wmem_default parameter is missing or it is less than 262,144 in some nodes. Set the value in ``/proc/sys/net/core/wmem_default`` to greater than or equal to 262,144 for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00290" mode="VERIFY" name="Sysrq Magic Keys">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[import %sys_req
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'sys_req')
 next compare('eq',$val,'1')
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies that Sysrq Magic Keys are enabled.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[Sysrq Magic Keys are enabled in ``/proc/sys/kernel/sysrq``.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Sysrq keys are not enabled in some nodes. Set the value in ``/proc/sys/kernel/sysrq`` to 1 for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00300" mode="VERIFY" name="Oracle Executable Linkage with async I/O">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'lib_aio')
 if !match($val,'io_getevents\@\@LIBAIO_\d+.\d+')
  call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'linked'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies Oracle executable linkage with async I/O.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="linked" result="PASSED" syntax="wiki"><![CDATA[The Oracle executable is linked with async I/O.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The Oracle executable is not linked with async I/O in some nodes. Link the Oracle executable with async I/O for the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00310" mode="VERIFY" name="hangcheck-timer">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'hng_chk')
 if !compare('eq',$val,'hangcheck-timer')
  call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the Linux hangcheck-timer parameter.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The Linux hangcheck-timer module is loaded.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The Linux hangcheck-timer module is not loaded in some nodes. Load the hangcheck-timer module in the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00320" mode="VERIFY" name="aio-max-size Setting">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'aio_max')
 next expr('>=',$val,1048576)
 call push(@tbl,concat($nod,':',nvl($val,'Unknown')))
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies the aio-max-size setting.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The aio-max-size parameter is greater than or equal to 1,048,576.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Either the aio_max_size parameter is missing or it is less than 1,048,576 in some nodes. Set the value in ``/proc/sys/fs/aio-max-size`` to greater than or equal to 1,048,576 in the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00330" mode="VERIFY" name="Memory (32-bit)">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $bit = getDataValue($nod,'bit')
 var $mem = getDataValue($nod,'mem')
 var $sys = getDataValue($nod,'uname')
 if !and($bit,$mem,$sys)
  call push(@tbl,concat($nod,':Unknown'))
 elsif and(compare('eq',$bit,'32'),expr('>=',$mem,6291456))
 {if !match($sys,'hugemem')
   call push(@tbl,concat($nod,':',field('\s+',2,$sys)))
 }
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies memory (32-bit).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The hugemem kernel is installed for RAM greater than 6GiB (RH 32-bit only).]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The hugemem kernel is not installed for RAM greater than 6GiB (RH 32-bit only) in some nodes. Install the hugemem kernel in the failed nodes.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00340" mode="VERIFY" name="Swap (32-bit)">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $bit = getDataValue($nod,'bit')
 var $mem = getDataValue($nod,'mem')
 var $swp = getDataValue($nod,'swp')
 if !and($bit,$mem,$swp)
  call push(@tbl,concat('[',$nod,':]Unknown'))
 elsif compare('eq',$bit,'32')
 {if expr('<=',$mem,1048576)
  {next expr('>=',$swp,expr('*',2,$mem))
    call push(@tbl,concat('[',$nod,':]Swap<2RAM'))
  }
  elsif !expr('>=',$swp,2097152)
   call push(@tbl,concat('[',$nod,':]Swap<2GiB'))
 }
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies swap (32-bit).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The operating system swap space is OK.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Refer to the following table for the necessary action to take:
|*Return Value*|*Action*|
|...Swap<2RAM|The operating system swap space is less than twice the RAM in some nodes. The swap space should be greater than or equal to twice the RAM (twice physical RAM up to 2 GiB maximum for 32-bit).|
|...Swap<2GiB|The operating system swap space is less than 2 GiB in some nodes. The swap space should be equal to 2,146,754,560 (32-bit Linux 2 GiB maximum swap).|
|...Unknown|Check the connectivity to the reported nodes.|]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00350" mode="VERIFY" name="Swap (64-bit)">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $bit = getDataValue($nod,'bit')
 var $mem = getDataValue($nod,'mem')
 var $swp = getDataValue($nod,'swp')
 if !and($bit,$mem,$swp)
   call push(@tbl,concat('[',$nod,':]Unknown'))
 elsif compare('eq',getDataValue($nod,'bit'),'64')
 {if expr('<=',$mem,4194304)
  {next expr('>=',$swp,expr('*',2,$mem))
   call push(@tbl,concat('[',$nod,':]Swap<2RAM'))
  }
  elsif !expr('>=',$swp,$mem)
   call push(@tbl,concat('[',$nod,':]Swap<RAM'))
 }
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'OK'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies swap (64-bit).]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="OK" result="PASSED" syntax="wiki"><![CDATA[The operating system swap space is OK.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[Refer to the following table for the necessary action to take:
|*Return Value*|*Action*|
|...Swap<2RAM|The operating system swap space is less than twice the RAM in some nodes. For the nodes with RAM upto 4 GiB, the swap space should be greater than twice the RAM (RAM <= 4 GiB, SWAP >= 2*RAM).|
|...Swap<RAM|The operating system swap space is less than the RAM in some nodes. For nodes with RAM more than 4 GiB, the swap space should be greater than or equal to RAM (RAM > 4 GiB, SWAP >= RAM).|
|...Unknown|Check the connectivity to the reported nodes.|]]></sdp_action>
</sdp_actions>
</sdp_rule>
<sdp_rule id="P00360" mode="VERIFY" name="Patch List">
<sdp_dependencies>
<sdp_dependency condition="IS" id="P00210" minimum="PASSED" result="SKIPPED" value="No remote data"><![CDATA[Check the connectivity to the nodes.]]></sdp_dependency>
</sdp_dependencies>
<sdp_command type="RDA"><![CDATA[
loop $nod (getDataKeys())
{var $val = getDataValue($nod,'patch')
 next compare('eq',$val,'')
 call push(@tbl,concat($nod,':',nvl($val,'Unknown'))) 
}
call setHcveResult(cond(scalar(@tbl),join("\012",@tbl),'Complete'))
]]></sdp_command>
<sdp_description><![CDATA[This rule verifies that all patches are applied.]]></sdp_description>
<sdp_actions>
<sdp_action condition="==" minimum="Complete" result="PASSED" syntax="wiki"><![CDATA[All patches are applied.]]></sdp_action>
<sdp_action result="FAILED" syntax="wiki"><![CDATA[The listed patches are not applied in some nodes. Take the appropriate action.
When the status is 'Unknown', check the connectivity to the node.]]></sdp_action>
</sdp_actions>
</sdp_rule>
</sdp_group>
</sdp_content>
</sdp_diaglet>
