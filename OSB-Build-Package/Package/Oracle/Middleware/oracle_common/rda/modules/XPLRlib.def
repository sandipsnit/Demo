# XPLRlib.def: Defines Common Explorer Macros
# $Id: XPLRlib.def,v 1.31 2012/08/14 07:09:32 mschenke Exp $
# ARCS: $Header: /home/cvs/cvs/RDA_4/src/scripting/lib/modules/XPLRlib.def,v 1.31 2012/08/14 07:09:32 mschenke Exp $
#
# Change History
# 20120814  MSC  Extend the get_bin_tool macro.

=head1 NAME

XPLRlib - Defines Common Explorer Macros

=head1 DESCRIPTION

This persistent submodule regroups macros that are common to Explorer modules.

The following macros are available:

=cut

use Buffer
use Explorer

# Make the module persistent and share macros
keep $KEEP_BLOCK,@SHARE_MACROS,@RESET_MACROS
var @SHARE_MACROS = ('check_patch',\
  'do_collect_dir','do_collect_fil','do_collect_rem','do_collect_sel',\
  'do_command','do_exec','do_remote',\
  'get_arc','get_bin_tool','get_ips_base','get_ips_version','get_osv',\
  'get_pkg_base','get_pkg_version','get_sub','get_tmp','get_zones',\
  'has_zones',\
  'is_ips_installed','is_pkg_installed',\
  'log_critical','log_error','log_exec','log_info','log_missing','log_run',\
  'log_warning')
var @RESET_MACROS = @SHARE_MACROS

# Initialisation
var ($MOD) = @arg

var $ERR = '---## Associated Errors'
var $PID = getSetting('XPLR_PID')
var $PRE = "   \001"
keep $MOD,$PID,$PRE

=head2 S<check_patch($num,$rev[,$flg])>

This macro indicates wether the specified patch is installed and has the
minimal revision. When the flag is set, it requires that the specified
revision is installed and not obsoleted.

=cut

macro check_patch
{var ($num,$rev,$flg) = @arg

 # Check if a patch is requested
 if !?$num
  return true

 # Check if an adequate patch is installed
 if testFile('x','/usr/bin/showrev')
  var $cmd = '/usr/bin/showrev -p'
 elsif testFile('x','/usr/sbin/patchadd')
  var $cmd = '/usr/sbin/patchadd -p'
 if ?$cmd
 {# Looking for exact match
  if $flg
  {var $ret = false
   loop $lin (grepCommand($cmd,concat('\b',$num,'\-')))
   {var $lin = replace($lin,'Requires:.*$')
    if match($lin,'Obsoletes:.*\b',$num,'\-(\d+)\b')
    {if expr('>=',last,$rev)
      return false
    }
    elsif match($lin,'Patch:\s*',$num,'\-(\d+)\s')
    {var ($cur) = last
     if expr('>',$cur,$rev)
      return false
     if expr('==',$cur,$rev)
      var $ret = true
    }
   }
   return $ret
  }

  # For non-exact match, search in 'Patch' and 'Obsoletes' sections
  loop $lin (grepCommand($cmd,concat('\b',$num,'\-')))
  {var $lin = replace($lin,'Requires:.*$')
   var ($cur) = match($lin,concat('\b',$num,'-(\d+)\b'))
   if expr('>=',$cur,$rev)
    return true
  }
 }
 return false
}

=head2 S<do_collect_dir($pre,$dir[,$flg])>

This macro collects text files from the specifed directory. When the flag is
set, it collects files recursively in sub directories.

=cut

macro do_collect_dir
{var ($pre,$dir,$flg) = @arg

 loop $fil (grepDir([$dir],'^\.+$',cond($flg,'drv','nv')))
 {if testFile('fT',$pth = catFile($dir,$fil))
  {if collectFile(join('/',$pre,$fil),$pth)
   {write '|[[',last,'][_blank][',encode($pth),']] | ',getSize($pth),'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
    next
   }
  }
  if !testFile('d',$pth)
   write '|',encode($pth),' | ',getSize($pth),'|',\
         getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
 }
}

=head2 S<do_collect_fil(@rec)>

This macro collects a list of files. Each argument is either a text, a command
descriptor, or an array reference containing the Explorer report name, the full
path of the file to collect, an optional binary file indicator, an optional
link text, an optional pattern, and optional search option.

=cut

macro do_collect_fil
{loop $rec (@arg)
 {var $ref = ref($rec)
  if !$ref
   write $rec
  elsif compare('eq',$ref,'HASH')
   call caller:do_command($rec,undef,undef,'/')
  elsif defined($rec->[4])
   call do_collect_sel($rec->[0],$rec->[1],$rec->[4],$rec->[5],$rec->[6])
  elsif testDir('d',$rec->[1])
   call do_collect_dir($rec->[0],$rec->[1],$rec->[2])
  else
  {if testFile(cond($rec->[2],'f','fT'),$rec->[1])
   {if cond($rec->[2],collectData($rec->[0],$rec->[1]),\
                      collectFile($rec->[0],$rec->[1]))
    {write '|[[',last,'][_blank][',nvl($rec->[3],encode($rec->[1])),']] | ',\
           getSize($rec->[1]),'|',\
           getLastModify($rec->[1],'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
     next
    }
   }
   if testFile('e',$rec->[1])
    write '|',nvl($rec->[3],encode($rec->[1])),' | ',getSize($rec->[1]),'|',\
          getLastModify($rec->[1],'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
  }
 }
}

=head2 S<do_collect_rem($pre,$top,@rec)>

This macro collects a list of files. Each argument is either a text, a command
descriptor,an array reference containing the scope, the Explorer report name,
the full path of the file to collect, an optional binary file indicator, an
optional link text, an optional pattern, and optional search option.

Valid scopes are C<G> for the global zone, C<L> for the local zones, and C<B>
for both.

=cut

macro do_collect_rem
{var ($pre,$top,@fil) = @arg

 loop $rec (@fil)
 {var $ref = ref($rec)
  if !$ref
   write $rec
  elsif compare('eq',$ref,'HASH')
   call caller:do_command($rec,$pre,undef,$top)
  elsif compare('eq',$rec->[0],cond(defined($pre),'G','L'))
   next
  elsif defined($rec->[5])
   call do_collect_sel(join('/',$pre,$rec->[1]),catDir($top,$rec->[2]),\
                       $rec->[5],$rec->[6],$rec->[7])
  elsif testDir('d',catDir($top,$rec->[2]))
   call do_collect_dir(join('/',$pre,$rec->[1]),lastDir(),$rec->[3])
  else
  {if testFile(cond($rec->[3],'f','fT'),$pth = catFile($top,$rec->[2]))
   {if cond($rec->[3],collectData(join('/',$pre,$rec->[1]),$pth),\
                      collectFile(join('/',$pre,$rec->[1]),$pth))
    {write '|[[',last,'][_blank][',nvl($rec->[4],encode($pth)),']] | ',\
           getSize($pth),'|',\
           getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
     next
    }
   }
   if testFile('e',$pth)
    write '|',nvl($rec->[4],encode($pth)),' | ',getSize($pth),'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
  }
 }
}

=head2 S<do_collect_sel($pre,$dir,$pat[,$opt])>

This macro collects all files matching the specified pattern in the specified
directory. You can specify search options as an extra argumment.

=cut

macro do_collect_sel
{var ($pre,$dir,$pat,$opt,$idx) = @arg

 loop $fil (grepDir([$dir],$pat,nvl($opt,'n')))
 {if testDir('fT',$pth = catFile($dir,$fil))
  {if collectFile(join('/',$pre,$fil),$pth,$idx)
   {write '|[[',last,'][_blank][',encode($pth),']] | ',getSize($pth),'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
    next
   }
  }
  if !testFile('d',$pth)
   write '|',encode($pth),' | ',getSize($pth),'|',\
         getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
 }
}

=head2 S<do_command($rec[,$pre,$cmd,$top])>

This macro executes one command. Its definition hash can contain the following
keys:

=over 11

=item S<    B<'cat'> > Specifies the catalog entry type.

=item S<    B<'cmd'> > Specifies the command.

=item S<    B<'cnt'> > Specifies the associated count.

=item S<    B<'cod'> > Specifies the associated code.

=item S<    B<'det'> > Specifies the section title details.

=item S<    B<'fil'> > Specifies the source file.

=item S<    B<'key'> > Specifies the sorting criteria.

=item S<    B<'nam'> > Specifies the name of the Explorer target.

=item S<    B<'tbl'> > Specifies the table reference.

=item S<    B<'ttl'> > Specifies the section title.

=item S<    B<'txt'> > Specifies the associated text.

=back

It supports the following commands:

=over 11

=item o B<'ARRAY'>, which uses the C<cat>, C<det>, C<nam>, C<tbl>, C<ttl> keys

=item o B<'BEGIN'>, which uses the C<nam>, C<fil>, C<cnt> keys

=item o B<'CODE'>, which uses the C<cod> key

=item o B<'COMMENT'>, which uses the C<nam>, C<txt> keys

=item o B<'END'>, which uses the C<nam>, C<fil>, C<cnt> keys

=item o B<'HASH'>, which uses the C<cat>, C<det>, C<key>, C<nam>, C<tbl>,
C<ttl> keys

=item o B<'HEAD'>, which uses the C<nam>, C<fil>, C<cnt> keys

=item o B<'SLEEP'>, which uses the C<cnt> key

=item o B<'TAIL'>, which uses the C<nam>, C<fil>, C<cnt> keys

=item o B<'TITLE'>, which uses the C<txt> key

=item o B<'UNTITLE'>, which uses the C<cnt> key

=back

=cut

macro do_command
{var ($rec,$pre,$exe,$top) = @arg
 import $TOP
 keep $TOP

 var $cmd = $rec->{'cmd'}
 if compare('eq',$cmd,'ARRAY')
 {if exists($rec->{'tbl'})
  {var \@tbl = $rec->{'tbl'}
   prefix
   {if exists($rec->{'ttl'})
     write $rec->{'ttl'}
    if exists($rec->{'det'})
     write '---## Using: ',$rec->{'det'}
    if exists($rec->{'nam'})
     call addBlock('E',nvl($rec->{'cat'},'O'),join('/',$pre,$rec->{'nam'}))
    call beginBlock(true)
   }
   loop $lin (@tbl)
    write $lin
   if hasOutput(true)
   {call endBlock()
    write $TOP
   }
  }
 }
 elsif or($flg = compare('eq',$cmd,'BEGIN'),compare('eq',$cmd,'END'))
 {if testFile('fT',$pth = catFile($top,$rec->{'fil'}))
  {var ($cnt,$nam) = ($rec->{'cnt'},join('/',$pre,$rec->{'nam'}))
   var ($typ,$dsc) = cond($flg,('h','First '),\
                               ('t','Last '))
   if $buf = new('Buffer',$typ,$pth,$cnt)
   {var $lnk = encode($pth)
    var $siz = getSize($pth)
    if $buf->is_complete
     var ($typ,$dsc) = ('F',concat(' ',$siz))
    else
     var $dsc = concat($dsc,$cnt,' bytes ')
    if $siz
    {var $rpt = $[OUT]->add_report('d',$nam,0,'.lin')
     if $rpt->write_data($buf,['F',$pth,uc($typ),'D'],['E','B',$nam])
      var $lnk = concat('[[',$rpt->get_raw(true),'][_blank][',$lnk,']]')
     call $[OUT]->end_report($rpt)
    }
    write '|',$lnk,' |',$dsc,'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
   }
  }
  elsif testFile('e',$pth)
    write '|',encode($pth),' | ',getSize($pth),'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
 }
 elsif compare('eq',$cmd,'CODE')
  call eval($rec->{'cod'})
 elsif compare('eq',$cmd,'COMMENT')
 {call addBlock('E','T',join('/',$pre,$rec->{'nam'}))
  call writeComment($rec->{'txt'})
 }
 elsif compare('eq',$cmd,'HASH')
 {if exists($rec->{'tbl'})
  {var \%tbl = $rec->{'tbl'}
   prefix
   {if exists($rec->{'ttl'})
     write $rec->{'ttl'}
    if exists($rec->{'det'})
     write '---## Using: ',$rec->{'det'}
    if exists($rec->{'nam'})
     call addBlock('E',nvl($rec->{'cat'},'O'),join('/',$pre,$rec->{'nam'}))
    call beginBlock(true)
   }
   loop $key (keys(%tbl,nvl($rec->{'key'},'KA')))
    write $tbl{$key}
   if hasOutput(true)
   {call endBlock()
    write $TOP
   }
  }
 }
 elsif or($flg = compare('eq',$cmd,'HEAD'),compare('eq',$cmd,'TAIL'))
 {if testFile('fT',$pth = catFile($top,$rec->{'fil'}))
  {var ($cnt,$nam) = ($rec->{'cnt'},join('/',$pre,$rec->{'nam'}))
   if $buf = new('Buffer','r',$pth)
   {var $lnk = encode($pth)
    if getSize($pth)
    {var $rpt = $[OUT]->add_report('d',$nam,0,'.lin')
     if cond($flg,\
             $rpt->write_lines($buf,1,$cnt,['F',$pth,'','T'],['E','D',$nam]),\
             $rpt->write_tail($buf,$cnt,['F',$pth,'F','T'],['E','D',$nam]))
      var $lnk = concat('[[',$rpt->get_raw(true),'][_blank][',$lnk,']]')
     call $[OUT]->end_report($rpt)
    }
    write '|',$lnk,' |',cond($flg,'First ','Last '),$cnt,' lines |',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
   }
  }
  elsif testFile('e',$pth)
   write '|',encode($pth),' | ',getSize($pth),'|',\
          getLastModify($pth,'%d-%b-%Y&nbsp;%H:%M:%S'),' |'
 }
 elsif compare('eq',$cmd,'SLEEP')
  sleep $cnt
 elsif compare('eq',$cmd,'TITLE')
  title $rec->{'txt'}
 elsif compare('eq',$cmd,'UNTITLE')
  untitle nvl($rec->{'cnt'},1)
}

=head2 S<do_exec(@rec)>

This macro executes a list of commands. Each argument is either a text, a
command descriptor, an array reference, or a hash reference. An array contains
the Explorer report name, the full path of the command to execute, the command
argument, the corresponding title, and an optional extension suppression
indicator. A hash is treated by the C<do_command> macro.

=cut

macro do_exec
 call caller:do_remote(undef,undef,'/',@arg)

=head2 S<do_remote($pre,$cmd,$top,@rec)>

This macro executes a list of commands on a remote system. Each argument is
either a text, a command descriptor, an array reference, or a hash
reference. The array contains the Explorer report name, the command to execute,
the corresponding title, and an optional extension suppression indicator. A
hash is treated by the C<do_command> macro.

It prefixes all report names and commands respectively by the first and second
arguments.

=cut

macro do_remote
{var ($pre,$exe,$top,@rec) = @arg
 import $ERR,$TOP
 keep $ERR,$TOP

 loop $rec (@rec)
 {var $ref = ref($rec)
  if !$ref
   write $rec
  elsif compare('eq',$ref,'HASH')
   call caller:do_command($rec,$pre,$exe,$top)
  elsif !?$rec->[1]
  {write $rec->[3]
   call beginBlock(true)
   call addBlock('E','O',join('/',$pre,$rec->[0]))
   write $rec->[2]
   call endBlock()
   write $TOP
  }
  elsif !testFile('f',catFile($top,$rec->[1]))
   call log_missing(lastFile())
  elsif !testFile('x',lastFile())
   call log_exec(lastFile())
  else
  {var $cmd = join(' ',$exe,quote($rec->[1],'x'),$rec->[2])
   if compare('eq',ref($dsc = $rec->[4]),'HASH')
   {prefix
    {write $rec->[3]
     write '---## Using: ',nvl($dsc->{'det'},encode($cmd))
    }
    if exists($dsc->{'nul'})
    {var $dsc = {%{$dsc->{'nul'}}}
     call addBlock('E',cond(exists($dsc->{'cat'}),$dsc->{'cat'},'O'),\
       concat($rec->[0],cond(exists($dsc->{'ext'}),$dsc->{'ext'},'.out')))
     call writeCommand(concat($cmd,' 2>/dev/null'))
    }
    else
     call collectCommand({nam=>join('/',$pre,$rec->[0]),\
       cond(exists($dsc->{'req'}),%{$dsc->{'req'}},\
            exists($dsc->{'inp'}),list(inp=>$dsc->{'inp'}),\
                                  list()),\
       out=>{blk=>true,flt=>true,idx=>true,rpt=>${CUR.REPORT},\
             cond(exists($dsc->{'out'}),%{$dsc->{'out'}},list())},\
       err=>{blk=>true,flt=>true,hdr=>$ERR,rpt=>${CUR.REPORT},\
             cond(exists($dsc->{'err'}),%{$dsc->{'err'}},list())}\
       },$cmd)
   }
   else
   {prefix
    {write $rec->[3]
     write '---## Using: ',encode($cmd)
    }
    call collectCommand({nam=>join('/',$pre,$rec->[0]),\
      out=>{blk=>true,flt=>true,idx=>true,rpt=>${CUR.REPORT},\
            cond(ref($rec->[4]),%{$rec->[4]},$rec->[4],list(ext=>''),list())},\
      err=>{blk=>true,flt=>true,hdr=>$ERR,rpt=>${CUR.REPORT}}\
      },$cmd)
   }
   if hasOutput(true)
    write $TOP
  }
 }
}

=head1 SYSTEM-RELATED MACROS

=head2 S<get_arc()>

This macro returns the system architecture. Typical values on Solaris are
C<i386> and C<sparc>.

=cut

macro get_arc
{if ?${XPLR_ARC}
  return last
 var ($val) = command(check(${RDA.OS},'solaris','/usr/bin/uname -p',\
                                                '/bin/uname -p'))
 if compare('eq',$val,'unknown')
  var $val = uname('m')
 call setTempSetting('XPLR_ARC',$val)
 return $val
}

=head2 S<get_bin_tool($name)>

This macro returns the path to a tool present in the Explorer F<bin> directory
structure.

=cut

macro get_bin_tool
{var ($nam,$flg) = @arg

 macro extract_top_dir
 {if ?readLink(@arg)
   return $[RDA]->clean_path(catDir(dirname(last),upDir()),true)
  return undef
 }

 var $top = nvl(getSetting('XPLR_TOP'),\
                get_ips_base('support/explorer','^(.*/explorer)/bin/explorer'),\
                get_pkg_base('SUNWexplo','SUNWexplo'),\
                extract_top_dir('/usr/sbin/explorer'),\
                getGroupDir('D_RDA','../explorer'))
 if or(testFile('d',$dir = catDir($top,'bin')),\
       testFile('d',$dir = catDir($top = '/usr/lib/explorer','bin')),\
       testFile('d',$dir = catDir($top = '/opt/SUNWexplo','bin')))
 {if or(testFile('fx',catFile($dir,get_sub(),concat($nam,'.',get_arc()))),\
        testFile('fx',catFile($dir,get_sub(),$nam)),\
        testFile('fx',catFile($dir,concat($nam,'.',get_arc()))),\
        testFile('fx',catFile($dir,$nam)))
   return cond($flg,(lastFile(),$top),lastFile())
 }
 return undef
}

=head2 S<get_osv()>

This macro returns the second part of the operating system version.

=cut

macro get_osv
{if ?${XPLR_OSV}
  return last
 call setTempSetting('XPLR_OSV',$val = field('\.',1,uname('r')))
 return $val
}

=head2 S<get_sub()>

This macro returns the operating system-specific sub directory.

=cut

macro get_sub
{if ?${XPLR_SUB}
  return last
 call setTempSetting('XPLR_SUB',$val = check(${RDA.OS},'solaris','solaris',\
                                                       'linux',  'linux',\
                                                       'cygwin', 'cygwin',\
                                                                 undef))
 return $val
}

=head2 S<get_tmp()>

This macro returns the path to the secure temporary directory.

=cut

macro get_tmp
{if ?${XPLR_TMP}
  return last
 return ${OUT.T}
}

=head2 S<get_zones([$default])>

This macro returns a list of zone descriptors, controlled by the
C<XPLR_GLOBAL>, C<XPLR_LOCAL>, and C<XPLR_ZONES> settings. Each descriptor is
an array reference containing the zone name, the zone root directory, the
operating system version, and the zone status.

When present, the global zone descriptor is the first descriptor of the list
and as an undefined value as name and as status.

You can specify the default value of the C<XPLR_LOCAL> setting as an argument.

=cut

# Build the list of zones to treat
macro get_zones
{var ($dft) = @arg
 var ($tbl,@zon) = ()

 # Identify the relevant local zones
 if ${XPLR_LOCAL:$dft}
 {# Check for zone restrictions
  if ?${XPLR_ZONES}
  {loop $nam (split('\s*,\s*',last))
    var $tbl->{$nam} = 1
  }

  # Find the local zones
  loop $val(grepCommand('/usr/sbin/zoneadm list -p','^[^:]*:global:','v'))
  {var (undef,$nam,$sta,$top) = split(':',$val)
   next and($tbl,missing($tbl->{$nam}))
   var ($ver) = command(concat('/usr/sbin/zlogin ',$nam,' /usr/bin/uname -r'))
   call push(@zon,[$nam,catDir($top,'root'),$ver,$sta])
  }
 }

 # Add the global zone as first element unless requested to skip it.
 if ${XPLR_GLOBAL:true}
  call unshift(@zon,[undef,'/',uname('r')])

 # Return the list of zones
 return @zon
}

=head2 S<has_zones()>

This macro indicates whether the current system can have zones.

=cut

macro has_zones
 return and(${OS.solaris},expr('>=',get_osv(),10))

=head1 PACKAGE-RELATED MACROS

=head2 S<get_ips_base($pkg,$pat)>

This macro returns the installation base for the specified IPS package. It
requires a pattern to extract the directory from the package content. For
example,

  get_ips_base('support/explorer','^(.*usr/lib)/bin/explorer')

=cut

macro get_ips_base
{var ($pkg,$pat) = @arg
 if grepCommand(concat('/usr/bin/pkg contents ',$pkg,' 2>/dev/null'),$pat,'f1')
  return catDir('',last)
 return undef
}

=head2 S<get_ips_version($pkg)>

This macro returns the version of the specified IPS package.

=cut

macro get_ips_version
{var ($pkg) = @arg
 var ($ver) = grepCommand(concat('/usr/bin/pkg info -l ',$pkg,' 2>/dev/null'),\
                          'VERSION:\s*(\d+(\.\d+)+)','f1')
 return $ver
}

=head2 S<get_pkg_base($pkg[,@sub])>

This macro returns the installation base for the specified SRV4 package. You
can specify extra arguments to return a subdirectory.

=cut

macro get_pkg_base
{var ($pkg,@sub) = @arg
 if grepCommand(concat('/usr/bin/pkginfo -r ',$pkg,' 2>/dev/null'),'^\/','f')
  return catDir(last,@sub)
 return undef
}

=head2 S<get_pkg_version($pkg)>

This macro returns the version of the specified SVR4 package.

=cut

macro get_pkg_version
{var ($pkg) = @arg
 var ($ver) = grepCommand(concat('/usr/bin/pkginfo -l ',$pkg,' 2>/dev/null'),\
                          'VERSION:\s*(\d+(\.\d+)+)','f1')
 return $ver
}

=head2 S<is_ips_installed($pkg)>

This macro indicates whether the specified IPS package is installed.

=cut

macro is_ips_installed
{var ($pkg) = @arg
 keep %cch

 if exists($cch{$pkg})
  return $cch{$pkg}
 call command(concat('/usr/bin/pkg info ',$pkg,' 2>&1'))
 return $cch{$pkg} = not(status())
}

=head2 S<is_pkg_installed($pkg)>

This macro indicates whether the specified SVR4 package is installed.

=cut

macro is_pkg_installed
{var ($pkg) = @arg
 keep %cch

 if exists($cch{$pkg})
  return $cch{$pkg}
 call command(concat('/usr/bin/pkginfo -q ',$pkg,' 2>&1'))
 return $cch{$pkg} = not(status())
}

=head1 LOG-RELATED MACROS

=head2 S<log_critical($msg[,$alt])>

This macro treats a critical message.

=cut

macro log_critical
{var ($msg,$alt) = @arg
 import $MOD,$PID
 keep $MOD,$PID

 if $PID
 {var $pre = concat(localtime('%b %d %H:%M:%S'),' ',${RDA.NODE},'[',last,'] ',\
    $MOD,':')
  echo $pre,"\001",$msg
  call $[XPL]->log($pre,' ',$msg)
 }
 else
  echo ' ',tput('bold'),nvl($alt,$msg),tput('off')
}

=head2 S<log_error($msg[,$alt])>

This macro treats an error message.

=cut

macro log_error
{var ($msg,$alt) = @arg
 import $MOD,$PID,$PRE
 keep $MOD,$PID,$PRE

 if $PID
 {var $pre = concat(localtime('%b %d %H:%M:%S'),' ',${RDA.NODE},'[',last,'] ',\
    $MOD,':')
  echo $pre,"\001ERROR  ",$msg
  call $[XPL]->log($pre,' ERROR  ',$msg)
 }
 else
  echo $PRE,nvl($alt,$msg)
 return true
}

=head2 S<log_exec($fil[,$alt])>

This macro generates a warning message the first time that it reports a file as
not executable.

=cut

macro log_exec
{var ($fil,$alt) = @arg
 keep %tbl

 if missing($tbl{$fil})
 {call log_warning(concat('Cannot execute ',$fil),$alt)
  var $tbl{$fil} = 1
 }
}

=head2 S<log_info($msg[,$alt])>

This macro treats an informative message.

=cut

macro log_info
{var ($msg,$alt) = @arg
 import $MOD,$PID,$PRE
 keep $MOD,$PID,$PRE

 if $PID
 {var $pre = concat(localtime('%b %d %H:%M:%S'),' ',${RDA.NODE},'[',last,'] ',\
    $MOD,':')
  debug $pre,"\001",$msg
  call $[XPL]->log($pre,' ',$msg)
 }
 elsif match($msg = nvl($alt,$msg),'^\s')
  debug $msg
 else
  debug $PRE,$msg
 return true
}

=head2 S<log_missing($fil[,$alt])>

This macro generates a warning message the first time that it reports a file as
missing.

=cut

macro log_missing
{var ($fil,$alt) = @arg
 keep %tbl

 if missing($tbl{$fil})
 {call log_warning(concat($fil,' not found'),$alt)
  var $tbl{$fil} = 1
 }
}

=head2 S<log_run($msg)>

This macro treats a module execution message.

=cut

macro log_run
 return log_critical('RUNNING',@arg)

=head2 S<log_warning($msg[,$alt])>

This macro treats a warning message.

=cut

macro log_warning
{var ($msg,$alt) = @arg
 import $MOD,$PID,$PRE
 keep $MOD,$PID,$PRE

 if $PID
 {var $pre = concat(localtime('%b %d %H:%M:%S'),' ',${RDA.NODE},'[',last,'] ',\
    $MOD,':')
  debug $pre,"\001WARNING  ",$msg
  call $[XPL]->log($pre,' WARNING  ',$msg)
 }
 else
  debug $PRE,nvl($alt,$msg)
 return true
}

=head1 SEE ALSO

L<S150XPLR.def|modules::S150XPLR>

=head1 COPYRIGHT NOTICE

Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.

=head1 TRADEMARK NOTICE

Oracle and Java are registered trademarks of Oracle and/or its
affiliates. Other names may be trademarks of their respective owners.

=cut
